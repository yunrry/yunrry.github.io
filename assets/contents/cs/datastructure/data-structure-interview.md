# ìë£Œêµ¬ì¡° ë©´ì ‘/ì„œìˆ 

## 1. ìŠ¤íƒ 2ê°œë¡œ í êµ¬í˜„

### ğŸ“Œ í•µì‹¬ ì•„ì´ë””ì–´

**ë‘ ê°œì˜ ìŠ¤íƒ(stack1, stack2)ì„ ì‚¬ìš©í•˜ì—¬ FIFO ë™ì‘ êµ¬í˜„**

---

### ğŸ’¡ ë™ì‘ ì›ë¦¬

### êµ¬ì¡°
```
stack1 (enqueueìš©)    stack2 (dequeueìš©)
â”Œâ”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”
â”‚     â”‚              â”‚     â”‚
â”‚     â”‚              â”‚     â”‚
â””â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”˜
```

### ê·œì¹™
1. **Enqueue**: stack1ì— push
2. **Dequeue**: 
   - stack2ê°€ ë¹„ì–´ìˆìœ¼ë©´ â†’ stack1ì˜ ëª¨ë“  ì›ì†Œë¥¼ stack2ë¡œ ì´ë™
   - stack2ì—ì„œ pop

---

## ğŸ’» êµ¬í˜„ ì½”ë“œ (Cì–¸ì–´)

```c
#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

typedef struct {
    Stack stack1;  // enqueueìš©
    Stack stack2;  // dequeueìš©
} QueueWithStacks;

// ìŠ¤íƒ ê¸°ë³¸ ì—°ì‚°
void initStack(Stack* s) {
    s->top = -1;
}

int isEmpty(Stack* s) {
    return s->top == -1;
}

void push(Stack* s, int value) {
    if (s->top >= MAX_SIZE - 1) return;
    s->data[++(s->top)] = value;
}

int pop(Stack* s) {
    if (isEmpty(s)) return -1;
    return s->data[(s->top)--];
}

// í ì´ˆê¸°í™”
void initQueue(QueueWithStacks* q) {
    initStack(&q->stack1);
    initStack(&q->stack2);
}

// Enqueue: stack1ì— push
void enqueue(QueueWithStacks* q, int value) {
    push(&q->stack1, value);
}

// Dequeue: stack2ì—ì„œ pop
int dequeue(QueueWithStacks* q) {
    // stack2ê°€ ë¹„ì–´ìˆìœ¼ë©´ stack1ì˜ ì›ì†Œë¥¼ ëª¨ë‘ ì´ë™
    if (isEmpty(&q->stack2)) {
        while (!isEmpty(&q->stack1)) {
            int value = pop(&q->stack1);
            push(&q->stack2, value);
        }
    }
    
    // stack2ê°€ ì—¬ì „íˆ ë¹„ì–´ìˆìœ¼ë©´ íê°€ ë¹ˆ ê²ƒ
    if (isEmpty(&q->stack2)) {
        return -1;  // ì—ëŸ¬
    }
    
    return pop(&q->stack2);
}
```

---

## ğŸ“Š ë™ì‘ ì˜ˆì‹œ

### ì˜ˆì‹œ 1: ê¸°ë³¸ ë™ì‘

```
ì´ˆê¸° ìƒíƒœ:
stack1: []
stack2: []

1. enqueue(1)
stack1: [1]
stack2: []

2. enqueue(2)
stack1: [1, 2]
stack2: []

3. enqueue(3)
stack1: [1, 2, 3]
stack2: []

4. dequeue() â†’ stack2ê°€ ë¹„ì–´ìˆìŒ
   stack1ì˜ ëª¨ë“  ì›ì†Œë¥¼ stack2ë¡œ ì´ë™:
   
   stack1ì—ì„œ pop: 3, 2, 1 ìˆœì„œë¡œ
   stack2ì— push: 3, 2, 1 ìˆœì„œë¡œ
   
   ê²°ê³¼:
   stack1: []
   stack2: [3, 2, 1]  (topì´ 1)
   
   stack2ì—ì„œ pop() â†’ 1 ë°˜í™˜

5. dequeue() â†’ stack2ê°€ ë¹„ì–´ìˆì§€ ì•ŠìŒ
   stack2: [3, 2]
   2 ë°˜í™˜

6. enqueue(4)
   stack1: [4]
   stack2: [3]

7. dequeue()
   stack2: [3] â†’ 3 ë°˜í™˜
   
8. dequeue() â†’ stack2ê°€ ë¹„ì–´ìˆìŒ
   stack1ì˜ 4ë¥¼ stack2ë¡œ ì´ë™
   stack2: [4] â†’ 4 ë°˜í™˜
```

---

## ğŸ¯ ì‹œê°„ë³µì¡ë„ ë¶„ì„

### Enqueue
```
ì‹œê°„ë³µì¡ë„: O(1)
- stack1ì— pushë§Œ í•˜ë©´ ë¨
```

### Dequeue
```
ìµœì„ ì˜ ê²½ìš°: O(1)
- stack2ì— ì›ì†Œê°€ ìˆìœ¼ë©´ ë°”ë¡œ pop

ìµœì•…ì˜ ê²½ìš°: O(N)
- stack2ê°€ ë¹„ì–´ìˆì–´ì„œ stack1ì˜ ëª¨ë“  ì›ì†Œ(Nê°œ)ë¥¼ ì´ë™

ë¶„í•  ìƒí™˜ ë¶„ì„ (Amortized): O(1)
- ê° ì›ì†ŒëŠ” ìµœëŒ€ 2ë²ˆë§Œ ì´ë™ (stack1â†’stack2, stack2ì—ì„œ pop)
- Në²ˆì˜ ì—°ì‚°ì— ëŒ€í•´ ì´ 2Në²ˆì˜ ì‘ì—… â†’ O(1)
```

---

## ğŸ’¬ ë©´ì ‘ ë‹µë³€ ì˜ˆì‹œ

### ì§§ì€ ë‹µë³€
```
ë‘ ê°œì˜ ìŠ¤íƒì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
- stack1ì€ enqueue ì „ìš©
- stack2ëŠ” dequeue ì „ìš©

Enqueue ì‹œ stack1ì— pushí•˜ê³ ,
Dequeue ì‹œ stack2ê°€ ë¹„ì–´ìˆìœ¼ë©´ stack1ì˜ ëª¨ë“  ì›ì†Œë¥¼ 
stack2ë¡œ ì˜®ê¸´ í›„ popí•©ë‹ˆë‹¤.

ì´ë ‡ê²Œ í•˜ë©´ FIFO ìˆœì„œê°€ ë³´ì¥ë©ë‹ˆë‹¤.
```

### ìƒì„¸ ë‹µë³€
```
ìŠ¤íƒì€ LIFO êµ¬ì¡°ì¸ë°, ë‘ ê°œë¥¼ ì‚¬ìš©í•˜ë©´ íì˜ FIFOë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë™ì‘ ì›ë¦¬:
1. EnqueueëŠ” í•­ìƒ stack1ì— push
2. DequeueëŠ” stack2ì—ì„œ pop
   - stack2ê°€ ë¹„ì–´ìˆìœ¼ë©´ stack1ì˜ ëª¨ë“  ì›ì†Œë¥¼ ë’¤ì§‘ì–´ì„œ ì´ë™

ì™œ ë™ì‘í•˜ëŠ”ê°€?
- stack1ì—ì„œ stack2ë¡œ ì´ë™í•  ë•Œ ìˆœì„œê°€ ë’¤ì§‘í™ë‹ˆë‹¤
- ë‘ ë²ˆ ë’¤ì§‘ìœ¼ë©´ ì›ë˜ ìˆœì„œë¡œ ë³µì›ë©ë‹ˆë‹¤
- ë”°ë¼ì„œ ë¨¼ì € ë“¤ì–´ì˜¨ ì›ì†Œê°€ ë¨¼ì € ë‚˜ê°‘ë‹ˆë‹¤

ì‹œê°„ë³µì¡ë„:
- Enqueue: O(1)
- Dequeue: ë¶„í•  ìƒí™˜ O(1)
  (ìµœì•…ì˜ ê²½ìš° O(N)ì´ì§€ë§Œ, ê° ì›ì†ŒëŠ” ìµœëŒ€ 2ë²ˆë§Œ ì´ë™)

ê³µê°„ë³µì¡ë„: O(N) (ë‘ ìŠ¤íƒ í•©ì³ì„œ)
```

---

# 2. HashMap ë™ì‘ ì›ë¦¬

## ğŸ“Œ HashMapì´ë€?

**Key-Value ìŒì„ ì €ì¥í•˜ëŠ” ìë£Œêµ¬ì¡°ë¡œ, í•´ì‹œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í‰ê·  O(1)ì˜ ê²€ìƒ‰/ì‚½ì…/ì‚­ì œ ì„±ëŠ¥ ì œê³µ**

---

## ğŸ’¡ ë™ì‘ ì›ë¦¬

### 1. ê¸°ë³¸ êµ¬ì¡°

```
HashMap ë‚´ë¶€:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë°°ì—´ (Bucket)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [0] â†’ NULL      â”‚
â”‚ [1] â†’ NULL      â”‚
â”‚ [2] â†’ (k3, v3)  â”‚
â”‚ [3] â†’ NULL      â”‚
â”‚ [4] â†’ (k1, v1)  â”‚
â”‚ [5] â†’ NULL      â”‚
â”‚ [6] â†’ (k2, v2)  â”‚
â”‚ [7] â†’ NULL      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. í•´ì‹œ í•¨ìˆ˜

```
hash(key) â†’ index

ì˜ˆì‹œ:
key = "apple"
hash("apple") = 12345
index = 12345 % 8 = 5

â†’ ë°°ì—´ì˜ 5ë²ˆ ì¸ë±ìŠ¤ì— ì €ì¥
```

---

## ğŸ”§ ì£¼ìš” ì—°ì‚°

### 1. Put (ì‚½ì…)

```java
public void put(K key, V value) {
    // 1. í•´ì‹œ ì½”ë“œ ê³„ì‚°
    int hash = key.hashCode();
    
    // 2. ë°°ì—´ ì¸ë±ìŠ¤ ê³„ì‚°
    int index = hash % buckets.length;
    
    // 3. í•´ë‹¹ ì¸ë±ìŠ¤ì— ì €ì¥
    buckets[index] = new Entry(key, value);
}
```

### 2. Get (ì¡°íšŒ)

```java
public V get(K key) {
    // 1. í•´ì‹œ ì½”ë“œ ê³„ì‚°
    int hash = key.hashCode();
    
    // 2. ë°°ì—´ ì¸ë±ìŠ¤ ê³„ì‚°
    int index = hash % buckets.length;
    
    // 3. í•´ë‹¹ ì¸ë±ìŠ¤ì—ì„œ ê°’ ë°˜í™˜
    Entry entry = buckets[index];
    return entry != null ? entry.value : null;
}
```

---

## âš ï¸ í•´ì‹œ ì¶©ëŒ (Hash Collision)

### ì¶©ëŒì´ë€?

**ì„œë¡œ ë‹¤ë¥¸ í‚¤ê°€ ê°™ì€ ì¸ë±ìŠ¤ë¥¼ ê°€ë¦¬í‚¤ëŠ” í˜„ìƒ**

```
hash("apple") % 8 = 5
hash("banana") % 8 = 5  â† ì¶©ëŒ!

ë‘˜ ë‹¤ ì¸ë±ìŠ¤ 5ë¥¼ ê°€ë¦¬í‚´
```

---

## ğŸ› ï¸ í•´ì‹œ ì¶©ëŒ í•´ê²° ë°©ë²•

### ë°©ë²• 1: ì²´ì´ë‹ (Chaining) â­

**ê°™ì€ ì¸ë±ìŠ¤ì— ì—¬ëŸ¬ ì›ì†Œë¥¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥**

```
Bucket ë°°ì—´:
[0] â†’ NULL
[1] â†’ NULL
[2] â†’ (k3, v3) â†’ NULL
[3] â†’ NULL
[4] â†’ NULL
[5] â†’ (apple, 100) â†’ (banana, 200) â†’ NULL  â† ì—°ê²° ë¦¬ìŠ¤íŠ¸
[6] â†’ (k2, v2) â†’ NULL
[7] â†’ NULL
```

#### êµ¬í˜„ (Java)

```java
class HashMap<K, V> {
    private static class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> next;  // ì—°ê²° ë¦¬ìŠ¤íŠ¸
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Entry<K, V>[] buckets;
    
    public void put(K key, V value) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        // ì´ë¯¸ í‚¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value;  // ê°’ ì—…ë°ì´íŠ¸
                return;
            }
            entry = entry.next;
        }
        
        // ìƒˆ ë…¸ë“œë¥¼ ë§¨ ì•ì— ì‚½ì…
        Entry<K, V> newEntry = new Entry<>(key, value);
        newEntry.next = buckets[index];
        buckets[index] = newEntry;
    }
    
    public V get(K key) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        // ì—°ê²° ë¦¬ìŠ¤íŠ¸ ìˆœíšŒ
        while (entry != null) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
            entry = entry.next;
        }
        
        return null;  // ëª» ì°¾ìŒ
    }
}
```

#### ì‹œê°„ë³µì¡ë„

```
í‰ê· : O(1)
- ì¶©ëŒì´ ì ìœ¼ë©´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ê°€ ì§§ìŒ

ìµœì•…: O(N)
- ëª¨ë“  ì›ì†Œê°€ í•œ ì¸ë±ìŠ¤ì— ëª°ë¦¼
- ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ëê¹Œì§€ ìˆœíšŒ

ì‹¤ì œë¡œëŠ”:
- Java 8+: ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ê°€ 8 ì´ìƒì´ë©´ Red-Black Treeë¡œ ë³€í™˜
- ìµœì•…ì˜ ê²½ìš° O(log N)ìœ¼ë¡œ ê°œì„ 
```

---

### ë°©ë²• 2: ê°œë°© ì£¼ì†Œë²• (Open Addressing)

**ì¶©ëŒ ì‹œ ë‹¤ë¥¸ ë¹ˆ ë²„í‚·ì„ ì°¾ì•„ ì €ì¥**

#### 2-1. ì„ í˜• íƒì‚¬ (Linear Probing)

```
ì¶©ëŒ ì‹œ ë°”ë¡œ ë‹¤ìŒ ì¸ë±ìŠ¤ í™•ì¸

index = hash(key) % size
ì¶©ëŒ ì‹œ: (index + 1) % size
ë˜ ì¶©ëŒ: (index + 2) % size
...

ì˜ˆì‹œ:
hash("apple") % 8 = 5
[5]ê°€ ì°¨ìˆìŒ â†’ [6] í™•ì¸
[6]ì´ ì°¨ìˆìŒ â†’ [7] í™•ì¸
[7]ì´ ë¹„ì–´ìˆìŒ â†’ ì €ì¥!
```

**ë¬¸ì œì : í´ëŸ¬ìŠ¤í„°ë§ (Clustering)**
```
[3][4][5][6][7] ëª¨ë‘ ì°¨ìˆìœ¼ë©´
ë‹¤ìŒ ì‚½ì…ë„ ì´ ì˜ì—­ì— ëª°ë¦¼ â†’ ì„±ëŠ¥ ì €í•˜
```

#### 2-2. ì œê³± íƒì‚¬ (Quadratic Probing)

```
ì¶©ëŒ ì‹œ ì œê³±ìˆ˜ë§Œí¼ ì´ë™

index = hash(key) % size
ì¶©ëŒ ì‹œ: (index + 1Â²) % size = (index + 1) % size
ë˜ ì¶©ëŒ: (index + 2Â²) % size = (index + 4) % size
ë˜ ì¶©ëŒ: (index + 3Â²) % size = (index + 9) % size

í´ëŸ¬ìŠ¤í„°ë§ ì™„í™” âœ”
```

#### 2-3. ì´ì¤‘ í•´ì‹± (Double Hashing)

```
ë‘ ê°œì˜ í•´ì‹œ í•¨ìˆ˜ ì‚¬ìš©

index = hash1(key) % size
ì¶©ëŒ ì‹œ: (index + hash2(key)) % size
ë˜ ì¶©ëŒ: (index + 2 * hash2(key)) % size

ìµœì†Œ í´ëŸ¬ìŠ¤í„°ë§ âœ”
```

---

## ğŸ“Š ì²´ì´ë‹ vs ê°œë°© ì£¼ì†Œë²• ë¹„êµ

| êµ¬ë¶„ | ì²´ì´ë‹ | ê°œë°© ì£¼ì†Œë²• |
|------|--------|------------|
| **êµ¬í˜„** | ê°„ë‹¨ âœ” | ë³µì¡ |
| **ë©”ëª¨ë¦¬** | ì¶”ê°€ ë©”ëª¨ë¦¬ (í¬ì¸í„°) | ë°°ì—´ë§Œ ì‚¬ìš© âœ” |
| **ìºì‹œ íš¨ìœ¨** | ë‚®ìŒ (í¬ì¸í„° ì¶”ì ) | ë†’ìŒ (ì—°ì† ë©”ëª¨ë¦¬) âœ” |
| **ì‚­ì œ** | ì‰¬ì›€ âœ” | ë³µì¡ (ì¬ë°°ì¹˜ í•„ìš”) |
| **ë¡œë“œíŒ©í„°** | 1 ì´ìƒ ê°€ëŠ¥ âœ” | 1 ë¯¸ë§Œë§Œ ê°€ëŠ¥ |
| **ìµœì•… ì„±ëŠ¥** | O(N), Java 8+ëŠ” O(log N) | O(N) |

---

## ğŸ”„ ë¦¬ì‚¬ì´ì§• (Resizing)

### ë¡œë“œ íŒ©í„° (Load Factor)

```
ë¡œë“œ íŒ©í„° = (ì €ì¥ëœ ì›ì†Œ ìˆ˜) / (ë²„í‚· í¬ê¸°)

ì˜ˆ: 16ê°œ ë²„í‚·ì— 12ê°œ ì›ì†Œ ì €ì¥
â†’ ë¡œë“œ íŒ©í„° = 12/16 = 0.75
```

### ë¦¬ì‚¬ì´ì§• ê¸°ì¤€

```
Java HashMap:
- ê¸°ë³¸ ë¡œë“œ íŒ©í„°: 0.75
- ë¡œë“œ íŒ©í„° ì´ˆê³¼ ì‹œ â†’ ë²„í‚· í¬ê¸° 2ë°° í™•ì¥

ì˜ˆ: 16 â†’ 32 â†’ 64 â†’ 128 ...
```

### ë¦¬ì‚¬ì´ì§• ê³¼ì •

```
1. ìƒˆë¡œìš´ í° ë°°ì—´ ìƒì„± (2ë°° í¬ê¸°)
2. ëª¨ë“  ì›ì†Œë¥¼ ìƒˆ ë°°ì—´ë¡œ ì¬ë°°ì¹˜ (rehashing)
   - í•´ì‹œê°’ì€ ë™ì¼í•˜ì§€ë§Œ ì¸ë±ìŠ¤ê°€ ë³€ê²½ë¨
   - index = hash % newSize

ì‹œê°„ë³µì¡ë„: O(N)
- ëª¨ë“  ì›ì†Œë¥¼ ë‹¤ì‹œ ì‚½ì…í•´ì•¼ í•¨

ë¶„í•  ìƒí™˜: O(1)
- ë¦¬ì‚¬ì´ì§•ì€ ê°€ë”ë§Œ ë°œìƒ
```

---

## ğŸ’¬ ë©´ì ‘ ë‹µë³€ ì˜ˆì‹œ

### ì§§ì€ ë‹µë³€
```
HashMapì€ í•´ì‹œ í•¨ìˆ˜ë¡œ í‚¤ë¥¼ ë°°ì—´ ì¸ë±ìŠ¤ë¡œ ë³€í™˜í•˜ì—¬
í‰ê·  O(1)ì— ë°ì´í„°ë¥¼ ì €ì¥/ì¡°íšŒí•©ë‹ˆë‹¤.

ì¶©ëŒ ë°œìƒ ì‹œ:
1. ì²´ì´ë‹: ê°™ì€ ì¸ë±ìŠ¤ì— ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥
2. ê°œë°© ì£¼ì†Œë²•: ë‹¤ë¥¸ ë¹ˆ ë²„í‚·ì„ ì°¾ì•„ ì €ì¥

JavaëŠ” ì²´ì´ë‹ ë°©ì‹ì„ ì‚¬ìš©í•˜ë©°,
ë¡œë“œ íŒ©í„°ê°€ 0.75 ì´ˆê³¼ ì‹œ ë°°ì—´ í¬ê¸°ë¥¼ 2ë°°ë¡œ í™•ì¥í•©ë‹ˆë‹¤.
```

### ìƒì„¸ ë‹µë³€
```
HashMap ë™ì‘ ì›ë¦¬:

1. ë°ì´í„° ì €ì¥:
   - í‚¤ì˜ hashCode() í˜¸ì¶œ
   - í•´ì‹œê°’ì„ ë°°ì—´ í¬ê¸°ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ê°€ ì¸ë±ìŠ¤
   - í•´ë‹¹ ì¸ë±ìŠ¤ì— (key, value) ì €ì¥

2. í•´ì‹œ ì¶©ëŒ í•´ê²°:
   
   ì²´ì´ë‹ (Java ì‚¬ìš©):
   - ê°™ì€ ì¸ë±ìŠ¤ì— ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥
   - Java 8+: ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ 8 ì´ìƒì´ë©´ Red-Black Tree ë³€í™˜
   - ìµœì•… O(N) â†’ O(log N)ìœ¼ë¡œ ê°œì„ 
   
   ê°œë°© ì£¼ì†Œë²•:
   - ì„ í˜• íƒì‚¬: ë‹¤ìŒ ì¸ë±ìŠ¤ ìˆœì°¨ í™•ì¸
   - ì œê³± íƒì‚¬: ì œê³±ìˆ˜ë§Œí¼ ì´ë™
   - ì´ì¤‘ í•´ì‹±: ë‘ ë²ˆì§¸ í•´ì‹œ í•¨ìˆ˜ ì‚¬ìš©

3. ë¦¬ì‚¬ì´ì§•:
   - ë¡œë“œ íŒ©í„°(ì›ì†Œìˆ˜/ë²„í‚·í¬ê¸°)ê°€ ì„ê³„ê°’(0.75) ì´ˆê³¼ ì‹œ
   - ë°°ì—´ í¬ê¸°ë¥¼ 2ë°°ë¡œ í™•ì¥
   - ëª¨ë“  ì›ì†Œë¥¼ ì¬ë°°ì¹˜ (rehashing)

ì‹œê°„ë³µì¡ë„:
- í‰ê· : O(1)
- ìµœì•…: O(N) (ì²´ì´ë‹), O(log N) (Java 8+ íŠ¸ë¦¬í™”)

ê³µê°„ë³µì¡ë„: O(N)
```

---

# 3. BST vs AVL Tree vs Red-Black Tree

## ğŸ“Š ë¹„êµ í‘œ

| êµ¬ë¶„ | BST | AVL Tree | Red-Black Tree |
|------|-----|----------|----------------|
| **ê· í˜•** | ì—†ìŒ | ì—„ê²©í•œ ê· í˜• | ëŠìŠ¨í•œ ê· í˜• |
| **ë†’ì´** | ìµœì•… O(N) | ìµœëŒ€ 1.44 log N | ìµœëŒ€ 2 log N |
| **íƒìƒ‰** | ìµœì•… O(N) | **O(log N)** | **O(log N)** |
| **ì‚½ì…** | í‰ê·  O(log N) | O(log N), íšŒì „ ë§ìŒ | **O(log N), íšŒì „ ì ìŒ** |
| **ì‚­ì œ** | í‰ê·  O(log N) | O(log N), íšŒì „ ë§ìŒ | **O(log N), íšŒì „ ì ìŒ** |
| **íšŒì „ ë¹ˆë„** | ì—†ìŒ | ë†’ìŒ (2íšŒì „ ì´ë‚´) | ë‚®ìŒ (3íšŒì „ ì´ë‚´) |
| **ì‚¬ìš© ì‚¬ë¡€** | ë‹¨ìˆœ êµ¬í˜„ | ê²€ìƒ‰ ë§ìŒ | ì‚½ì…/ì‚­ì œ ë§ìŒ |
| **êµ¬í˜„** | ê°„ë‹¨ âœ” | ë³µì¡ | ë§¤ìš° ë³µì¡ |

---

## 1ï¸âƒ£ BST (Binary Search Tree)

### íŠ¹ì§•
```
âœ” ì™¼ìª½ < ë£¨íŠ¸ < ì˜¤ë¥¸ìª½
âœ˜ ê· í˜• ë³´ì¥ ì—†ìŒ
âœ˜ í¸í–¥ íŠ¸ë¦¬ ê°€ëŠ¥
```

### êµ¬ì¡° ì˜ˆì‹œ

```
ê· í˜• ì¡íŒ BST:
         50
        /  \
      30    70
     / \    / \
   20  40 60  80

ë†’ì´: 3
íƒìƒ‰: O(log N) âœ”

í¸í–¥ëœ BST (ìµœì•…):
    10
      \
       20
         \
          30
            \
             40
              \
               50

ë†’ì´: 5
íƒìƒ‰: O(N) âœ˜ (ì—°ê²° ë¦¬ìŠ¤íŠ¸ì™€ ë™ì¼)
```

### ì¥ë‹¨ì 

```
ì¥ì :
âœ” êµ¬í˜„ì´ ê°„ë‹¨
âœ” í‰ê· ì ìœ¼ë¡œ O(log N) ì„±ëŠ¥
âœ” ì¤‘ìœ„ ìˆœíšŒ ì‹œ ì •ë ¬ëœ ê²°ê³¼

ë‹¨ì :
âœ˜ ìµœì•…ì˜ ê²½ìš° O(N)
âœ˜ ìˆœì°¨ ì‚½ì… ì‹œ í¸í–¥ íŠ¸ë¦¬
âœ˜ ê· í˜• ë³´ì¥ ì—†ìŒ
```

---

## 2ï¸âƒ£ AVL Tree

### íŠ¹ì§•

```
âœ” ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬
âœ” ëª¨ë“  ë…¸ë“œì˜ BF (Balance Factor) âˆˆ {-1, 0, 1}
âœ” ê°€ì¥ ì—„ê²©í•œ ê· í˜• ì¡°ê±´

BF = (ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ ë†’ì´) - (ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ ë†’ì´)
```

### ê· í˜• ì¸ìˆ˜ ì˜ˆì‹œ

```
âœ” ê· í˜• ì¡íŒ AVL:
         50 (BF=0)
        /  \
      30    70 (BF=0)
     / \      \
   20  40     80

âœ˜ ë¶ˆê· í˜• (BF=2):
         50 (BF=2)
        /
      30 (BF=1)
     /
   20

â†’ íšŒì „ í•„ìš”!
```

### íšŒì „ ì¢…ë¥˜

#### LL íšŒì „ (Right Rotation)
```
    30             20
   /       â†’      /  \
  20             10   30
 /
10
```

#### RR íšŒì „ (Left Rotation)
```
10                 20
  \       â†’       /  \
   20           10   30
     \
      30
```

#### LR íšŒì „ (Left-Right)
```
  30           30           20
 /      â†’     /      â†’     /  \
10           20           10   30
  \         /
   20      10
```

#### RL íšŒì „ (Right-Left)
```
10           10            20
  \    â†’       \     â†’    /  \
   30           20       10   30
  /              \
20               30
```

### ì¥ë‹¨ì 

```
ì¥ì :
âœ” í•­ìƒ O(log N) ë³´ì¥
âœ” ê²€ìƒ‰ ì„±ëŠ¥ì´ ê°€ì¥ ìš°ìˆ˜
âœ” ë†’ì´ê°€ ê°€ì¥ ë‚®ìŒ (ìµœëŒ€ 1.44 log N)

ë‹¨ì :
âœ˜ ì‚½ì…/ì‚­ì œ ì‹œ íšŒì „ ë¹ˆë²ˆ
âœ˜ êµ¬í˜„ ë³µì¡
âœ˜ ì˜¤ë²„í—¤ë“œ (BF ì €ì¥)
```

### ì‚¬ìš© ì‚¬ë¡€

```
âœ” ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤ (ê²€ìƒ‰ ì¤‘ì‹¬)
âœ” ì½ê¸° ì‘ì—…ì´ 99%
âœ” ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ (ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì„±ëŠ¥)
```

---

## 3ï¸âƒ£ Red-Black Tree

### íŠ¹ì§•

```
âœ” ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬
âœ” ê° ë…¸ë“œëŠ” ë¹¨ê°• ë˜ëŠ” ê²€ì •
âœ” AVLë³´ë‹¤ ëŠìŠ¨í•œ ê· í˜•
âœ” íšŒì „ ë¹ˆë„ ë‚®ìŒ
```

### ê·œì¹™ (5ê°€ì§€)

```
1. ëª¨ë“  ë…¸ë“œëŠ” ë¹¨ê°• ë˜ëŠ” ê²€ì •
2. ë£¨íŠ¸ëŠ” ê²€ì •
3. ëª¨ë“  ë¦¬í”„(NULL)ëŠ” ê²€ì •
4. ë¹¨ê°• ë…¸ë“œì˜ ìì‹ì€ ê²€ì •
   (ë¹¨ê°•-ë¹¨ê°• ì—°ì† ë¶ˆê°€)
5. ëª¨ë“  ê²½ë¡œì˜ ê²€ì • ë…¸ë“œ ìˆ˜ ë™ì¼
   (Black Height ì¼ì •)
```

### êµ¬ì¡° ì˜ˆì‹œ

```
       [20B]
      /     \
   [10R]   [30B]
   /  \     /  \
[5B] [15B] [25R] [40B]

B = Black, R = Red

ê·œì¹™ í™•ì¸:
âœ” ë£¨íŠ¸(20)ëŠ” ê²€ì •
âœ” ë¹¨ê°• ë…¸ë“œ(10, 25)ì˜ ìì‹ì€ ê²€ì •
âœ” ëª¨ë“  ê²½ë¡œì˜ ê²€ì • ë…¸ë“œ ìˆ˜ = 3
```

### íšŒì „ ë° ìƒ‰ ë³€ê²½

```
ì‚½ì…/ì‚­ì œ ì‹œ:
1. BST ê·œì¹™ëŒ€ë¡œ ì‚½ì…/ì‚­ì œ
2. ìƒˆ ë…¸ë“œëŠ” ë¹¨ê°•ìœ¼ë¡œ ì‚½ì…
3. Red-Black ê·œì¹™ ìœ„ë°˜ ì‹œ:
   - ìƒ‰ ë³€ê²½ (Recoloring)
   - íšŒì „ (Rotation)
```

### ì¥ë‹¨ì 

```
ì¥ì :
âœ” ì‚½ì…/ì‚­ì œê°€ AVLë³´ë‹¤ ë¹ ë¦„
âœ” íšŒì „ íšŸìˆ˜ ì ìŒ (ìµœëŒ€ 3íšŒ)
âœ” ìµœì•…ì˜ ê²½ìš°ë„ O(log N)
âœ” ì‹¤ë¬´ì—ì„œ ê°€ì¥ ë§ì´ ì‚¬ìš©

ë‹¨ì :
âœ˜ AVLë³´ë‹¤ ë†’ì´ê°€ ë†’ìŒ (ìµœëŒ€ 2 log N)
âœ˜ ê²€ìƒ‰ì´ AVLë³´ë‹¤ ì•½ê°„ ëŠë¦¼
âœ˜ êµ¬í˜„ì´ ë§¤ìš° ë³µì¡
```

### ì‚¬ìš© ì‚¬ë¡€

```
âœ” Java TreeMap, TreeSet
âœ” C++ STL map, set
âœ” Linux ì»¤ë„ (í”„ë¡œì„¸ìŠ¤ ìŠ¤ì¼€ì¤„ë§)
âœ” ì‚½ì…/ì‚­ì œê°€ ë¹ˆë²ˆí•œ ê²½ìš°
```

---

## ğŸ¯ ìƒì„¸ ë¹„êµ

### 1. ë†’ì´ ë¹„êµ

```
ê°™ì€ Nê°œ ë…¸ë“œ ì €ì¥ ì‹œ:

BST ë†’ì´:
- í‰ê· : 1.39 log N
- ìµœì•…: N (í¸í–¥ íŠ¸ë¦¬)

AVL ë†’ì´:
- ìµœëŒ€: 1.44 log N âœ” (ê°€ì¥ ë‚®ìŒ)

Red-Black ë†’ì´:
- ìµœëŒ€: 2 log N
```

### 2. ì—°ì‚° ë¹„êµ

```
1000ê°œ ë…¸ë“œ ê¸°ì¤€:

        | BST     | AVL      | RB-Tree
--------|---------|----------|----------
ê²€ìƒ‰    | í‰ê·  10 | ìµœëŒ€ 14  | ìµœëŒ€ 20
        | ìµœì•… 1000| âœ”       |
ì‚½ì…    | í‰ê·  10 | 14(íšŒì „) | 20(íšŒì „ì ìŒ) âœ”
ì‚­ì œ    | í‰ê·  10 | 14(íšŒì „) | 20(íšŒì „ì ìŒ) âœ”
```

### 3. íšŒì „ ë¹ˆë„

```
ì‚½ì… 1000ë²ˆ ê¸°ì¤€:

AVL Tree: í‰ê·  500ë²ˆ íšŒì „
Red-Black: í‰ê·  200ë²ˆ íšŒì „ âœ”

â†’ RB-Treeê°€ ì‚½ì…/ì‚­ì œì— ìœ ë¦¬
```

---

## ğŸ’¬ ë©´ì ‘ ë‹µë³€ ì˜ˆì‹œ

### ì§§ì€ ë‹µë³€

```
BST: ê¸°ë³¸ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬, ê· í˜• ë³´ì¥ ì—†ìŒ

AVL: ì—„ê²©í•œ ê· í˜• ìœ ì§€, ê²€ìƒ‰ ìµœì í™”
- BFê°€ í•­ìƒ -1, 0, 1
- ë†’ì´ê°€ ê°€ì¥ ë‚®ìŒ
- ê²€ìƒ‰ì´ ë§ì„ ë•Œ ì‚¬ìš©

Red-Black: ëŠìŠ¨í•œ ê· í˜•, ì‚½ì…/ì‚­ì œ ìµœì í™”
- ë¹¨ê°•/ê²€ì • ë…¸ë“œë¡œ ê· í˜• ìœ ì§€
- íšŒì „ ë¹ˆë„ ë‚®ìŒ
- ì‹¤ë¬´ì—ì„œ ê°€ì¥ ë§ì´ ì‚¬ìš© (Java TreeMap ë“±)
```

### ìƒì„¸ ë‹µë³€

```
1. BST (Binary Search Tree):
   - ì™¼ìª½ < ë£¨íŠ¸ < ì˜¤ë¥¸ìª½ ê·œì¹™ë§Œ ìœ ì§€
   - ê· í˜• ë³´ì¥ ì—†ì–´ì„œ í¸í–¥ íŠ¸ë¦¬ ê°€ëŠ¥
   - ìµœì•…ì˜ ê²½ìš° O(N)
   - êµ¬í˜„ì€ ê°„ë‹¨í•˜ì§€ë§Œ ì‹¤ë¬´ì—ì„  ì˜ ì•ˆ ì”€

2. AVL Tree:
   - ëª¨ë“  ë…¸ë“œì˜ Balance Factorê°€ -1, 0, 1
   - ê°€ì¥ ì—„ê²©í•œ ê· í˜• ì¡°ê±´
   - ë†’ì´ê°€ ìµœëŒ€ 1.44 log N (ê°€ì¥ ë‚®ìŒ)
   - ê²€ìƒ‰ ì„±ëŠ¥ì´ ìµœê³ 
   - í•˜ì§€ë§Œ ì‚½ì…/ì‚­ì œ ì‹œ íšŒì „ì´ ë¹ˆë²ˆ
   - ì‚¬ìš© ì‚¬ë¡€: ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤ (ê²€ìƒ‰ ì¤‘ì‹¬)

3. Red-Black Tree:
   - ë¹¨ê°•/ê²€ì • ë…¸ë“œë¡œ ê· í˜• ìœ ì§€
   - 5ê°€ì§€ ê·œì¹™ (ë£¨íŠ¸ëŠ” ê²€ì •, ë¹¨ê°•-ë¹¨ê°• ì—°ì† ë¶ˆê°€ ë“±)
   - ë†’ì´ê°€ ìµœëŒ€ 2 log N (AVLë³´ë‹¤ ë†’ìŒ)
   - í•˜ì§€ë§Œ íšŒì „ ë¹ˆë„ê°€ ë‚®ì•„ ì‚½ì…/ì‚­ì œê°€ ë¹ ë¦„
   - ì‹¤ë¬´ì—ì„œ ê°€ì¥ ë§ì´ ì‚¬ìš©
   - ì‚¬ìš© ì‚¬ë¡€: Java TreeMap, C++ map, Linux ì»¤ë„

ì„ íƒ ê¸°ì¤€:
- ê²€ìƒ‰ì´ 99% â†’ AVL Tree
- ì‚½ì…/ì‚­ì œê°€ ë¹ˆë²ˆ â†’ Red-Black Tree
- ë‹¨ìˆœ êµ¬í˜„ â†’ BST (ì‹¤ë¬´ì—ì„  ê±°ì˜ ì•ˆ ì”€)
```

---

# 4. Array vs ArrayList vs LinkedList

---

## ğŸ“Š ë¹„êµ í‘œ

| êµ¬ë¶„ | Array | ArrayList | LinkedList |
|------|-------|-----------|------------|
| **íƒ€ì…** | ê¸°ë³¸ ìë£Œêµ¬ì¡° | ë™ì  ë°°ì—´ | ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ |
| **í¬ê¸°** | ê³ ì • âœ˜ | ë™ì  âœ” | ë™ì  âœ” |
| **ë©”ëª¨ë¦¬** | ì—°ì†ì  | ì—°ì†ì  | ë¹„ì—°ì†ì  |
| **ì¸ë±ìŠ¤ ì ‘ê·¼** | O(1) âœ” | O(1) âœ” | O(N) âœ˜ |
| **ê²€ìƒ‰** | O(N) | O(N) | O(N) |
| **ë§¨ì• ì‚½ì…** | - | O(N) âœ˜ | O(1) âœ” |
| **ë§¨ë’¤ ì‚½ì…** | - | O(1) (ë¶„í• ìƒí™˜) | O(1) âœ” |
| **ì¤‘ê°„ ì‚½ì…** | - | O(N) | O(N) |
| **ë§¨ì• ì‚­ì œ** | - | O(N) âœ˜ | O(1) âœ” |
| **ë§¨ë’¤ ì‚­ì œ** | - | O(1) âœ” | O(1) âœ” |
| **ì¤‘ê°„ ì‚­ì œ** | - | O(N) | O(N) |
| **ë©”ëª¨ë¦¬ íš¨ìœ¨** | ë†’ìŒ âœ” | ì¤‘ê°„ | ë‚®ìŒ (í¬ì¸í„°) âœ˜ |
| **ìºì‹œ íš¨ìœ¨** | ë†’ìŒ âœ” | ë†’ìŒ âœ” | ë‚®ìŒ âœ˜ |
| **Null í—ˆìš©** | íƒ€ì…ì— ë”°ë¼ | âœ” | âœ” |
| **ì´ˆê¸° ìš©ëŸ‰** | í•„ìˆ˜ | ì„ íƒ (ê¸°ë³¸ 10) | ë¶ˆí•„ìš” |
| **Thread-Safe** | - | âœ˜ | âœ˜ |

---

## 1ï¸âƒ£ Array (ë°°ì—´)

### íŠ¹ì§•

```java
// ê³ ì • í¬ê¸°
int[] arr = new int[5];
String[] names = new String[10];

// í¬ê¸° ë³€ê²½ ë¶ˆê°€
arr[5] = 10;  // âœ˜ ArrayIndexOutOfBoundsException
```

### ë©”ëª¨ë¦¬ êµ¬ì¡°

```
int[] arr = {10, 20, 30, 40, 50};

ë©”ëª¨ë¦¬:
ì£¼ì†Œ   | 1000 | 1004 | 1008 | 1012 | 1016 |
-------|------|------|------|------|------|
ì¸ë±ìŠ¤ |  0   |  1   |  2   |  3   |  4   |
ê°’     |  10  |  20  |  30  |  40  |  50  |

ì—°ì†ëœ ë©”ëª¨ë¦¬ ê³µê°„ âœ”
```

### ì¥ë‹¨ì 

```
ì¥ì :
âœ” ì¸ë±ìŠ¤ë¡œ O(1) ì ‘ê·¼
âœ” ë©”ëª¨ë¦¬ íš¨ìœ¨ì  (ì˜¤ë²„í—¤ë“œ ì—†ìŒ)
âœ” ìºì‹œ ì¹œí™”ì 
âœ” ì›ì‹œ íƒ€ì… ì €ì¥ ê°€ëŠ¥
âœ” ì„±ëŠ¥ ìµœì í™”

ë‹¨ì :
âœ˜ í¬ê¸° ê³ ì • (ë³€ê²½ ë¶ˆê°€)
âœ˜ ì‚½ì…/ì‚­ì œ ì‹œ ìˆ˜ë™ ê´€ë¦¬ í•„ìš”
âœ˜ í¬ê¸° ì´ˆê³¼ ì‹œ ìƒˆ ë°°ì—´ ìƒì„± í•„ìš”
```

### ì‚¬ìš© ì‚¬ë¡€

```
âœ” í¬ê¸°ê°€ ê³ ì •ëœ ê²½ìš°
âœ” ë©”ëª¨ë¦¬ê°€ ì œí•œì ì¼ ë•Œ
âœ” ê³ ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ê²½ìš°
âœ” ì›ì‹œ íƒ€ì… ì €ì¥ (int, double ë“±)

ì˜ˆì‹œ:
- ê³ ì •ëœ í•™ìƒ ìˆ˜ (30ëª…)
- ìš”ì¼ ë°°ì—´ (7ê°œ)
- RGB ìƒ‰ìƒ (3ê°œ ê°’)
```

---

## 2ï¸âƒ£ ArrayList

### íŠ¹ì§•

```java
// ë™ì  í¬ê¸°
ArrayList<Integer> list = new ArrayList<>();

// ì´ˆê¸° ìš©ëŸ‰ ì§€ì • ê°€ëŠ¥
ArrayList<String> names = new ArrayList<>(100);

// í¬ê¸° ìë™ ì¡°ì ˆ
list.add(10);  // size: 1
list.add(20);  // size: 2
// ê³„ì† ì¶”ê°€ ê°€ëŠ¥... âœ”
```

### ë‚´ë¶€ êµ¬ì¡°

```java
public class ArrayList<E> {
    private Object[] elementData;  // ë‚´ë¶€ ë°°ì—´
    private int size;              // í˜„ì¬ ì›ì†Œ ìˆ˜
    
    private static final int DEFAULT_CAPACITY = 10;
}
```

### ë™ì  í™•ì¥ (Resizing)

```
ì´ˆê¸°: ìš©ëŸ‰ 10
[0][1][2][3][4][5][6][7][8][9]

10ê°œ ì±„ì›€:
[10][20][30][40][50][60][70][80][90][100]

11ë²ˆì§¸ ì¶”ê°€ ì‹œ:
1. ìƒˆ ë°°ì—´ ìƒì„± (ìš©ëŸ‰ 15 = 10 * 1.5)
2. ê¸°ì¡´ ì›ì†Œ ë³µì‚¬
3. ìƒˆ ì›ì†Œ ì¶”ê°€

[10][20][30][40][50][60][70][80][90][100][110][_][_][_][_]

ì‹œê°„ë³µì¡ë„:
- ì¼ë°˜ add: O(1)
- resizing ë°œìƒ: O(N)
- ë¶„í•  ìƒí™˜: O(1) âœ”
```

### ì£¼ìš” ë©”ì„œë“œ

```java
ArrayList<Integer> list = new ArrayList<>();

// ì‚½ì…
list.add(10);           // ë§¨ ë’¤: O(1)
list.add(0, 5);         // ë§¨ ì•: O(N)
list.add(2, 15);        // ì¤‘ê°„: O(N)

// ì ‘ê·¼
int value = list.get(2);  // O(1) âœ”

// ìˆ˜ì •
list.set(2, 20);        // O(1)

// ì‚­ì œ
list.remove(0);         // ë§¨ ì•: O(N)
list.remove(list.size()-1);  // ë§¨ ë’¤: O(1)
list.remove(Integer.valueOf(20));  // ê°’ìœ¼ë¡œ: O(N)

// ê²€ìƒ‰
int index = list.indexOf(20);  // O(N)
boolean exists = list.contains(20);  // O(N)

// í¬ê¸°
int size = list.size();
boolean empty = list.isEmpty();

// ìš©ëŸ‰
list.ensureCapacity(100);  // ë¯¸ë¦¬ ìš©ëŸ‰ í™•ë³´
list.trimToSize();         // ë¶ˆí•„ìš”í•œ ìš©ëŸ‰ ì œê±°
```

### ì¤‘ê°„ ì‚½ì…/ì‚­ì œ ê³¼ì •

```java
// ì¤‘ê°„ ì‚½ì…
list = [10, 20, 30, 40, 50]
list.add(2, 25);

1. ì¸ë±ìŠ¤ 2ë¶€í„° ë’¤ë¡œ ì´ë™:
[10, 20, 30, 40, 50, _]
[10, 20, 30, 30, 40, 50]

2. ì¸ë±ìŠ¤ 2ì— ì‚½ì…:
[10, 20, 25, 30, 40, 50]

// ì¤‘ê°„ ì‚­ì œ
list = [10, 20, 30, 40, 50]
list.remove(2);

1. ì¸ë±ìŠ¤ 2 ì‚­ì œ
2. ë’¤ì˜ ì›ì†Œë“¤ ì•ìœ¼ë¡œ ì´ë™:
[10, 20, 40, 50, _]

ì´ë™ íšŸìˆ˜: N - index
ì‹œê°„ë³µì¡ë„: O(N)
```

### ì¥ë‹¨ì 

```
ì¥ì :
âœ” ë™ì  í¬ê¸° ì¡°ì ˆ
âœ” ì¸ë±ìŠ¤ë¡œ O(1) ì ‘ê·¼
âœ” ì‚¬ìš©í•˜ê¸° í¸ë¦¬ (API í’ë¶€)
âœ” ìˆœì°¨ ì ‘ê·¼ ì‹œ ë¹ ë¦„ (ìºì‹œ íš¨ìœ¨)
âœ” ë©”ëª¨ë¦¬ ì—°ì† ë°°ì¹˜

ë‹¨ì :
âœ˜ ì¤‘ê°„ ì‚½ì…/ì‚­ì œ ëŠë¦¼ O(N)
âœ˜ Resizing ì˜¤ë²„í—¤ë“œ
âœ˜ ì´ˆê¸° ìš©ëŸ‰ ë‚­ë¹„ ê°€ëŠ¥
âœ˜ ì›ì‹œ íƒ€ì… ì €ì¥ ì‹œ Boxing í•„ìš”
```

### ì‚¬ìš© ì‚¬ë¡€

```
âœ” ì¸ë±ìŠ¤ ì ‘ê·¼ì´ ë¹ˆë²ˆí•  ë•Œ
âœ” ìˆœì°¨ ì ‘ê·¼ì´ ë§ì„ ë•Œ
âœ” ë§¨ ë’¤ ì‚½ì…/ì‚­ì œê°€ ì£¼ëœ ì‘ì—…
âœ” í¬ê¸° ì˜ˆì¸¡ ê°€ëŠ¥í•  ë•Œ

ì˜ˆì‹œ:
- ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
- ë¡œê·¸ ì €ì¥
- ë°ì´í„° ìˆ˜ì§‘ í›„ ë¶„ì„
```

---

## 3ï¸âƒ£ LinkedList

### íŠ¹ì§•

```java
// ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸
LinkedList<Integer> list = new LinkedList<>();

// ì–‘ë°©í–¥ ì ‘ê·¼ ê°€ëŠ¥
list.addFirst(10);   // ë§¨ ì• ì¶”ê°€
list.addLast(20);    // ë§¨ ë’¤ ì¶”ê°€
list.getFirst();     // ë§¨ ì• ì¡°íšŒ
list.getLast();      // ë§¨ ë’¤ ì¡°íšŒ
```

### ë‚´ë¶€ êµ¬ì¡°

```java
public class LinkedList<E> {
    private static class Node<E> {
        E item;
        Node<E> next;    // ë‹¤ìŒ ë…¸ë“œ
        Node<E> prev;    // ì´ì „ ë…¸ë“œ
        
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    
    private Node<E> first;  // ì²« ë…¸ë“œ
    private Node<E> last;   // ë§ˆì§€ë§‰ ë…¸ë“œ
    private int size;
}
```

### ë©”ëª¨ë¦¬ êµ¬ì¡°

```
LinkedList: [10, 20, 30, 40]

NULL â† [10|â—] â‡„ [20|â—] â‡„ [30|â—] â‡„ [40|â—] â†’ NULL
       â†‘                              â†‘
     first                          last

ê° ë…¸ë“œ:
- item: ë°ì´í„° (8ë°”ì´íŠ¸, ì°¸ì¡°)
- next: ë‹¤ìŒ ë…¸ë“œ í¬ì¸í„° (8ë°”ì´íŠ¸)
- prev: ì´ì „ ë…¸ë“œ í¬ì¸í„° (8ë°”ì´íŠ¸)

ì´ 24ë°”ì´íŠ¸/ë…¸ë“œ (ArrayListëŠ” 8ë°”ì´íŠ¸)
```

### ì£¼ìš” ë©”ì„œë“œ

```java
LinkedList<Integer> list = new LinkedList<>();

// ì‚½ì…
list.add(10);           // ë§¨ ë’¤: O(1)
list.addFirst(5);       // ë§¨ ì•: O(1) âœ”
list.addLast(15);       // ë§¨ ë’¤: O(1)
list.add(2, 12);        // ì¤‘ê°„: O(N)

// ì ‘ê·¼
int first = list.getFirst();   // O(1)
int last = list.getLast();     // O(1)
int value = list.get(2);       // O(N) âœ˜

// ì‚­ì œ
list.removeFirst();     // ë§¨ ì•: O(1) âœ”
list.removeLast();      // ë§¨ ë’¤: O(1) âœ”
list.remove(2);         // ì¤‘ê°„: O(N)

// í/ìŠ¤íƒ ì—°ì‚°
list.offer(10);        // í: enqueue
list.poll();           // í: dequeue
list.push(10);         // ìŠ¤íƒ: push
list.pop();            // ìŠ¤íƒ: pop
```

### ì¤‘ê°„ ì ‘ê·¼ ìµœì í™”

```java
// LinkedListì˜ get(index) êµ¬í˜„
public E get(int index) {
    // ì ˆë°˜ ê¸°ì¤€ìœ¼ë¡œ ì•/ë’¤ì—ì„œ íƒìƒ‰
    if (index < size / 2) {
        // ì•ì—ì„œë¶€í„° íƒìƒ‰
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x.item;
    } else {
        // ë’¤ì—ì„œë¶€í„° íƒìƒ‰
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x.item;
    }
}

í‰ê·  ì´ë™ íšŸìˆ˜: N/4
ì—¬ì „íˆ O(N)ì´ì§€ë§Œ ì‹¤ì œë¡œëŠ” 2ë°° ë¹ ë¦„
```

### ì¥ë‹¨ì 

```
ì¥ì :
âœ” ë§¨ ì•/ë’¤ ì‚½ì…/ì‚­ì œ O(1)
âœ” í¬ê¸° ì œí•œ ì—†ìŒ
âœ” Resizing ì˜¤ë²„í—¤ë“œ ì—†ìŒ
âœ” ë©”ëª¨ë¦¬ ë‹¨í¸í™” ë°©ì§€

ë‹¨ì :
âœ˜ ì¸ë±ìŠ¤ ì ‘ê·¼ O(N)
âœ˜ ë©”ëª¨ë¦¬ ì˜¤ë²„í—¤ë“œ (í¬ì¸í„°)
âœ˜ ìºì‹œ ë¹„íš¨ìœ¨ì 
âœ˜ ìˆœì°¨ ì ‘ê·¼ë„ ëŠë¦¼
```

### ì‚¬ìš© ì‚¬ë¡€

```
âœ” ë§¨ ì•/ë’¤ ì‚½ì…/ì‚­ì œê°€ ë¹ˆë²ˆí•  ë•Œ
âœ” í(Queue) êµ¬í˜„
âœ” ìŠ¤íƒ(Stack) êµ¬í˜„
âœ” ë±(Deque) êµ¬í˜„
âœ” ì¸ë±ìŠ¤ ì ‘ê·¼ì´ ì—†ì„ ë•Œ

ì˜ˆì‹œ:
- ë¸Œë¼ìš°ì € ë°©ë¬¸ ê¸°ë¡ (ì•/ë’¤ ì´ë™)
- ìŒì•… ì¬ìƒ ëª©ë¡
- Undo/Redo ê¸°ëŠ¥
- ì‘ì—… í
```

---

## ğŸ¯ ìƒì„¸ ë¹„êµ

### 1. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰

```java
// 1000ê°œ Integer ì €ì¥ ê¸°ì¤€

Array (int[]):
4ë°”ì´íŠ¸ Ã— 1000 = 4KB âœ”

ArrayList<Integer>:
- ë‚´ë¶€ ë°°ì—´: 8ë°”ì´íŠ¸ Ã— 1000 = 8KB (ì°¸ì¡°)
- Integer ê°ì²´: 16ë°”ì´íŠ¸ Ã— 1000 = 16KB
- ì´: 24KB

LinkedList<Integer>:
- ë…¸ë“œ: 24ë°”ì´íŠ¸ Ã— 1000 = 24KB
- Integer ê°ì²´: 16ë°”ì´íŠ¸ Ã— 1000 = 16KB
- ì´: 40KB âœ˜

LinkedListê°€ ArrayListë³´ë‹¤ 1.7ë°° ë§ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©
```

### 2. ì„±ëŠ¥ ë¹„êµ (ì‹¤ì¸¡)

```
10,000ê°œ ì›ì†Œ ê¸°ì¤€:

1. ìˆœì°¨ ì ‘ê·¼ (0ë¶€í„° 9999ê¹Œì§€):
   Array:      0.1ms âœ”
   ArrayList:  0.2ms
   LinkedList: 1500ms âœ˜ (15,000ë°° ëŠë¦¼!)

2. ëœë¤ ì ‘ê·¼ (ë¬´ì‘ìœ„ ì¸ë±ìŠ¤):
   Array:      0.5ms âœ”
   ArrayList:  0.6ms
   LinkedList: 750ms âœ˜

3. ë§¨ ì• ì‚½ì… 1000ë²ˆ:
   ArrayList:  150ms (ë§¤ë²ˆ ì´ë™)
   LinkedList: 0.1ms âœ”

4. ë§¨ ë’¤ ì‚½ì… 10,000ë²ˆ:
   ArrayList:  1ms âœ”
   LinkedList: 2ms

5. ì¤‘ê°„ ì‚½ì… 1000ë²ˆ:
   ArrayList:  80ms
   LinkedList: 90ms
   (ê±°ì˜ ë¹„ìŠ·, ë‘˜ ë‹¤ O(N))
```

### 3. ë°˜ë³µ ì„±ëŠ¥

```java
List<Integer> list = ... (10,000ê°œ)

// 1. for-each (Iterator ì‚¬ìš©)
for (Integer value : list) {
    // ...
}
// ArrayList: 1ms âœ”
// LinkedList: 2ms (ë…¸ë“œ íƒìƒ‰)

// 2. ì¸ë±ìŠ¤ ì ‘ê·¼
for (int i = 0; i < list.size(); i++) {
    int value = list.get(i);
}
// ArrayList: 1ms âœ”
// LinkedList: 1500ms âœ˜ (ì ˆëŒ€ ì‚¬ìš©í•˜ì§€ ë§ ê²ƒ!)

// 3. Iterator ì§ì ‘ ì‚¬ìš©
Iterator<Integer> it = list.iterator();
while (it.hasNext()) {
    int value = it.next();
}
// ArrayList: 1ms âœ”
// LinkedList: 2ms
```

**ê²°ë¡ : LinkedListëŠ” ë°˜ë“œì‹œ Iteratorë‚˜ for-each ì‚¬ìš©!**

---

## ğŸ’¬ ë©´ì ‘ ë‹µë³€ ì˜ˆì‹œ

### ì§§ì€ ë‹µë³€

```
Array:
- ê³ ì • í¬ê¸°, ì—°ì† ë©”ëª¨ë¦¬
- ì¸ë±ìŠ¤ ì ‘ê·¼ O(1)
- ì›ì‹œ íƒ€ì… ì €ì¥ ê°€ëŠ¥

ArrayList:
- ë™ì  ë°°ì—´ (ë‚´ë¶€ëŠ” ë°°ì—´)
- ì¸ë±ìŠ¤ ì ‘ê·¼ O(1)
- ë§¨ ë’¤ ì‚½ì…/ì‚­ì œ ë¹ ë¦„

LinkedList:
- ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸
- ë§¨ ì•/ë’¤ ì‚½ì…/ì‚­ì œ O(1)
- ì¸ë±ìŠ¤ ì ‘ê·¼ O(N)

ì„ íƒ ê¸°ì¤€:
- ì¸ë±ìŠ¤ ì ‘ê·¼ ë§ìŒ â†’ ArrayList
- ë§¨ ì• ì‚½ì…/ì‚­ì œ ë§ìŒ â†’ LinkedList
- ê³ ì • í¬ê¸° + ì›ì‹œ íƒ€ì… â†’ Array
```

### ìƒì„¸ ë‹µë³€

```
1. Array (ë°°ì—´):
   
   íŠ¹ì§•:
   - ê³ ì • í¬ê¸°, ì—°ì†ëœ ë©”ëª¨ë¦¬ ê³µê°„
   - ì»´íŒŒì¼ íƒ€ì„ì— í¬ê¸° ê²°ì •
   - ì›ì‹œ íƒ€ì…(int, double) ì§ì ‘ ì €ì¥ ê°€ëŠ¥
   
   ì„±ëŠ¥:
   - ì ‘ê·¼: O(1) âœ”
   - ë©”ëª¨ë¦¬: ê°€ì¥ íš¨ìœ¨ì  âœ”
   - ìºì‹œ: ê°€ì¥ íš¨ìœ¨ì  âœ”
   
   ì‚¬ìš©:
   - í¬ê¸° ê³ ì • (ìš”ì¼, RGB ê°’ ë“±)
   - ê³ ì„±ëŠ¥ í•„ìš” ì‹œ
   - ë©”ëª¨ë¦¬ ì œí•œì ì¼ ë•Œ

2. ArrayList:
   
   íŠ¹ì§•:
   - ë‚´ë¶€ì ìœ¼ë¡œ ë°°ì—´ ì‚¬ìš©
   - ë™ì  í¬ê¸° ì¡°ì ˆ (ìë™ í™•ì¥)
   - ê¸°ë³¸ ìš©ëŸ‰ 10, 1.5ë°°ì”© ì¦ê°€
   
   ì„±ëŠ¥:
   - ì ‘ê·¼: O(1) âœ”
   - ë§¨ ë’¤ ì‚½ì…: O(1) ë¶„í• ìƒí™˜
   - ì¤‘ê°„ ì‚½ì…/ì‚­ì œ: O(N) (ì›ì†Œ ì´ë™)
   - ë©”ëª¨ë¦¬: ì—°ì† ë°°ì¹˜ë¡œ ìºì‹œ íš¨ìœ¨ ë†’ìŒ
   
   ë‚´ë¶€ ë™ì‘:
   - ìš©ëŸ‰ ì´ˆê³¼ ì‹œ ìƒˆ ë°°ì—´ ìƒì„± ë° ë³µì‚¬
   - ë©”ëª¨ë¦¬ ì¬í• ë‹¹ ì˜¤ë²„í—¤ë“œ
   
   ì‚¬ìš©:
   - ì¸ë±ìŠ¤ ì ‘ê·¼ì´ ì£¼ëœ ì‘ì—…
   - ë§¨ ë’¤ ì‚½ì…ì´ ëŒ€ë¶€ë¶„
   - í¬ê¸° ì˜ˆì¸¡ ê°€ëŠ¥ (ì´ˆê¸° ìš©ëŸ‰ ì§€ì •)

3. LinkedList:
   
   íŠ¹ì§•:
   - ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (prev, next í¬ì¸í„°)
   - ë¹„ì—°ì†ì  ë©”ëª¨ë¦¬
   - first, last í¬ì¸í„°ë¡œ ì–‘ ë ê´€ë¦¬
   
   ì„±ëŠ¥:
   - ì ‘ê·¼: O(N) âœ˜ (ìˆœì°¨ íƒìƒ‰)
   - ë§¨ ì•/ë’¤ ì‚½ì…/ì‚­ì œ: O(1) âœ”
   - ì¤‘ê°„ ì‚½ì…/ì‚­ì œ: O(N) (ìœ„ì¹˜ ì°¾ê¸°)
   - ë©”ëª¨ë¦¬: í¬ì¸í„° ì˜¤ë²„í—¤ë“œ (ë…¸ë“œë‹¹ 24ë°”ì´íŠ¸)
   
   ì£¼ì˜ì‚¬í•­:
   - get(index) ì ˆëŒ€ ì‚¬ìš© ê¸ˆì§€!
   - Iteratorë‚˜ for-eachë§Œ ì‚¬ìš©
   
   ì‚¬ìš©:
   - í/ìŠ¤íƒ/ë± êµ¬í˜„
   - ë§¨ ì• ì‚½ì…/ì‚­ì œê°€ ë¹ˆë²ˆ
   - ì¸ë±ìŠ¤ ì ‘ê·¼ì´ ì—†ëŠ” ê²½ìš°

ì„±ëŠ¥ ë¹„êµ (10,000ê°œ ê¸°ì¤€):
                  | ArrayList | LinkedList
------------------|-----------|------------
ìˆœì°¨ ì ‘ê·¼         | 0.2ms âœ”  | 1500ms âœ˜
ë§¨ ì• ì‚½ì… 1000ë²ˆ | 150ms     | 0.1ms âœ”
ë©”ëª¨ë¦¬ (Integer)  | 24KB      | 40KB

ì„ íƒ ê¸°ì¤€:
- ì½ê¸°ê°€ 99% â†’ ArrayList
- ë§¨ ì• ì‘ì—…ì´ ë§ìŒ â†’ LinkedList
- ì›ì‹œ íƒ€ì… + ê³ ì • í¬ê¸° â†’ Array
- ì‹¤ë¬´ì—ì„œëŠ” ëŒ€ë¶€ë¶„ ArrayList ì‚¬ìš©
```

---

## ğŸ“ ì¶”ê°€ íŒ

### ArrayList ìµœì í™”

```java
// âœ˜ ë¹„íš¨ìœ¨ì 
ArrayList<Integer> list = new ArrayList<>();
for (int i = 0; i < 10000; i++) {
    list.add(i);  // ì—¬ëŸ¬ ë²ˆ resizing
}

// âœ” íš¨ìœ¨ì 
ArrayList<Integer> list = new ArrayList<>(10000);
for (int i = 0; i < 10000; i++) {
    list.add(i);  // resizing ì—†ìŒ
}
```

### LinkedList ì£¼ì˜ì‚¬í•­

```java
LinkedList<Integer> list = ...;

// âœ˜ ì ˆëŒ€ ê¸ˆì§€! O(NÂ²)
for (int i = 0; i < list.size(); i++) {
    int value = list.get(i);  // ë§¤ë²ˆ O(N)
}

// âœ” ì˜¬ë°”ë¥¸ ë°©ë²• O(N)
for (Integer value : list) {
    // ...
}

// âœ” Iterator ì‚¬ìš©
Iterator<Integer> it = list.iterator();
while (it.hasNext()) {
    int value = it.next();
}
```

### Thread-Safe ë²„ì „

```java
// ArrayList
List<Integer> syncList = Collections.synchronizedList(new ArrayList<>());

// CopyOnWriteArrayList (ì½ê¸°ê°€ ë§ì„ ë•Œ)
List<Integer> cowList = new CopyOnWriteArrayList<>();

// LinkedList
List<Integer> syncLinked = Collections.synchronizedList(new LinkedList<>());
```

---

**í•µì‹¬ ì •ë¦¬:**
1. **ì¸ë±ìŠ¤ ì ‘ê·¼ì´ ë§ìœ¼ë©´ ArrayList**
2. **ë§¨ ì•/ë’¤ ì‘ì—…ì´ ë§ìœ¼ë©´ LinkedList**
3. **ê³ ì • í¬ê¸° + ì›ì‹œ íƒ€ì…ì´ë©´ Array**
4. **ì‹¤ë¬´ì—ì„œëŠ” ëŒ€ë¶€ë¶„ ArrayList ì‚¬ìš©**
5. **LinkedListëŠ” get(index) ì ˆëŒ€ ì‚¬ìš© ê¸ˆì§€!**
