<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>LeetCode 933. Number of Recent Calls - Second Brain</title>
<meta name="description" content="2026년 목표: 개발로 월급받기추가 정보 없음">


  <meta name="author" content="yunYoung e">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Second Brain">
<meta property="og:title" content="LeetCode 933. Number of Recent Calls">
<meta property="og:url" content="http://localhost:4000/assets/contents/algorithm/leetcode-933/">


  <meta property="og:description" content="2026년 목표: 개발로 월급받기추가 정보 없음">












<link rel="canonical" href="http://localhost:4000/assets/contents/algorithm/leetcode-933/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "yunYoung e",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Second Brain Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>


  
    <script src="/assets/js/custom.js"></script>
  


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--default">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Second Brain
          <span class="site-subtitle">뇌정리노트</span>
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
<h1 id="leetcode-933-number-of-recent-calls">LeetCode 933. Number of Recent Calls</h1>

<h2 id="-결과">📊 결과</h2>
<ul>
  <li><strong>소요시간</strong>: 20분</li>
  <li><strong>Runtime</strong>: 24ms (Beats 51.71%)</li>
  <li><strong>Memory</strong>: 55.98MB</li>
</ul>

<hr />

<h2 id="-내-코드">💻 내 코드</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecentCounter</span> <span class="o">{</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">deque</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">t</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">RecentCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="n">count</span><span class="o">++;</span>
        
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-</span><span class="mi">3000</span><span class="o">){</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">){</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="-평가">📝 평가</h2>

<h3 id="-잘한-점">✅ 잘한 점</h3>

<ol>
  <li><strong>Deque 선택</strong>: 양쪽에서 삭제 가능한 자료구조 사용</li>
  <li><strong>슬라이딩 윈도우 개념</strong>: 3000ms 범위 유지 시도</li>
  <li><strong>오래된 요청 제거</strong>: 왼쪽에서 범위 밖 요청 제거</li>
  <li><strong>정답 도출</strong>: 모든 테스트 케이스 통과</li>
</ol>

<h3 id="-개선점">🔴 개선점</h3>

<ol>
  <li>
    <p><strong>불필요한 로직</strong>:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">){</span>
     <span class="n">deque</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
     <span class="n">count</span><span class="o">--;</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>이 부분은 절대 실행되지 않음!</strong></li>
      <li>왜? <code class="language-plaintext highlighter-rouge">t</code>는 항상 증가하는 값 (문제 조건)</li>
      <li><code class="language-plaintext highlighter-rouge">deque.peekLast()</code>는 방금 추가한 <code class="language-plaintext highlighter-rouge">t</code>이므로 절대 <code class="language-plaintext highlighter-rouge">t</code>보다 클 수 없음</li>
    </ul>
  </li>
  <li>
    <p><strong>불필요한 변수들</strong>:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">t</span><span class="o">;</span>      <span class="c1">// 사용 안 함</span>
 <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>  <span class="c1">// deque.size()로 대체 가능</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>변수 섀도잉</strong>:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 파라미터 t</span>
     <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>            <span class="c1">// 멤버 변수 t</span>
</code></pre></div>    </div>

    <ul>
      <li>혼란스러운 네이밍</li>
    </ul>
  </li>
  <li>
    <p><strong>메모리</strong>: count를 따로 관리할 필요 없이 <code class="language-plaintext highlighter-rouge">deque.size()</code> 사용 가능</p>
  </li>
</ol>

<hr />

<h2 id="-최적화된-풀이">✨ 최적화된 풀이</h2>

<h3 id="방법-1-깔끔한-queue-방식-추천-">방법 1: 깔끔한 Queue 방식 (추천 ⭐⭐⭐⭐⭐)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecentCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">requests</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">RecentCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">requests</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 새 요청 추가</span>
        <span class="n">requests</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        
        <span class="c1">// 3000ms 이전 요청 제거</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">requests</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">3000</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">requests</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">requests</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>개선 포인트</strong>:</p>

<ul>
  <li>✅ 불필요한 변수 제거 (t, count)</li>
  <li>✅ 불필요한 while 루프 제거</li>
  <li>✅ Queue 인터페이스 사용 (용도에 맞음)</li>
  <li>✅ 간결한 로직</li>
</ul>

<p><strong>시간복잡도</strong>: O(1) amortized (각 요청은 최대 1번 추가, 1번 제거) <strong>공간복잡도</strong>: O(W) (W = 3000ms 내 요청 수, 최대 3000개)</p>

<hr />

<h3 id="방법-2-deque-활용-원본과-유사하지만-개선">방법 2: Deque 활용 (원본과 유사하지만 개선)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecentCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">deque</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">RecentCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        
        <span class="c1">// 범위 밖 요청 제거</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekFirst</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">3000</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">deque</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">deque</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="방법-3-treemap-활용-오버킬이지만-확장성">방법 3: TreeMap 활용 (오버킬이지만 확장성)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecentCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>  <span class="c1">// &lt;time, count&gt;</span>
    
    <span class="kd">public</span> <span class="nf">RecentCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        
        <span class="c1">// t-3000 미만 제거</span>
        <span class="n">map</span><span class="o">.</span><span class="na">headMap</span><span class="o">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">3000</span><span class="o">,</span> <span class="kc">false</span><span class="o">).</span><span class="na">clear</span><span class="o">();</span>
        
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>용도</strong>: 같은 시간에 여러 요청이 올 수 있는 경우</p>

<hr />

<h3 id="방법-4-배열-기반-메모리-최적화">방법 4: 배열 기반 (메모리 최적화)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecentCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">times</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">RecentCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">times</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10000</span><span class="o">];</span>  <span class="c1">// 충분한 크기</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">times</span><span class="o">[</span><span class="n">end</span><span class="o">++]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">times</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">3000</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">start</span><span class="o">++;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>장점</strong>: 객체 생성 오버헤드 없음</p>

<hr />

<h2 id="-성능-비교">📊 성능 비교</h2>

<table>
  <thead>
    <tr>
      <th>방법</th>
      <th>시간복잡도</th>
      <th>공간복잡도</th>
      <th>Runtime</th>
      <th>Memory</th>
      <th>가독성</th>
      <th>추천도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>원본 코드</td>
      <td>O(1) amortized</td>
      <td>O(W)</td>
      <td>24ms</td>
      <td>55.98MB</td>
      <td>⭐⭐⭐</td>
      <td>⭐⭐⭐</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>O(1) amortized</td>
      <td>O(W)</td>
      <td>18-20ms</td>
      <td>54MB</td>
      <td>⭐⭐⭐⭐⭐</td>
      <td>⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
      <td>Deque</td>
      <td>O(1) amortized</td>
      <td>O(W)</td>
      <td>18-20ms</td>
      <td>54MB</td>
      <td>⭐⭐⭐⭐⭐</td>
      <td>⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
      <td>TreeMap</td>
      <td>O(log W)</td>
      <td>O(W)</td>
      <td>30-40ms</td>
      <td>56MB</td>
      <td>⭐⭐⭐</td>
      <td>⭐⭐</td>
    </tr>
    <tr>
      <td>배열</td>
      <td>O(1) amortized</td>
      <td>O(1) 고정</td>
      <td>16-18ms</td>
      <td>53MB</td>
      <td>⭐⭐⭐</td>
      <td>⭐⭐⭐⭐</td>
    </tr>
  </tbody>
</table>

<p><strong>W</strong> = 3000ms 윈도우 내 요청 수 (최대 3000개)</p>

<hr />

<h2 id="-핵심-인사이트">💡 핵심 인사이트</h2>

<h3 id="문제-이해">문제 이해</h3>

<p><strong>요구사항</strong>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ping(t)</code> 호출 시, 최근 3000ms 내의 요청 수 반환</li>
  <li>즉, <code class="language-plaintext highlighter-rouge">[t-3000, t]</code> 범위의 요청 개수</li>
</ul>

<p><strong>예시</strong>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RecentCounter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RecentCounter</span><span class="o">();</span>
<span class="n">counter</span><span class="o">.</span><span class="na">ping</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>     <span class="c1">// [1] → 1</span>
<span class="n">counter</span><span class="o">.</span><span class="na">ping</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>   <span class="c1">// [1, 100] → 2</span>
<span class="n">counter</span><span class="o">.</span><span class="na">ping</span><span class="o">(</span><span class="mi">3001</span><span class="o">);</span>  <span class="c1">// [100, 3001] → 2 (1은 범위 밖)</span>
<span class="n">counter</span><span class="o">.</span><span class="na">ping</span><span class="o">(</span><span class="mi">3002</span><span class="o">);</span>  <span class="c1">// [100, 3001, 3002] → 3</span>
</code></pre></div></div>

<hr />

<h3 id="슬라이딩-윈도우-패턴">슬라이딩 윈도우 패턴</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간 →
     ┌────── 3000ms ──────┐
     │                    │
┌────┴────┬────┬────┬─────▼──┬────┐
│ 1      │100 │3001│3002   │    │
└─────────┴────┴────┴────────┴────┘
  제거      유지  유지  현재

ping(3002) 호출 시:
- 1은 3002-3000=2보다 작음 → 제거
- 100, 3001은 범위 내 → 유지
- 3002 추가
→ 총 3개
</code></pre></div></div>

<hr />

<h3 id="배운-점">배운 점</h3>

<ol>
  <li>
    <p><strong>문제 조건 활용</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 문제: ping 호출은 strictly increasing order
 즉, t는 항상 증가
    
 → deque의 뒤쪽은 확인할 필요 없음!
 → 오른쪽 제거 로직 불필요
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>적절한 자료구조</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Queue: 앞에서 제거, 뒤에 추가 → 완벽!
 Deque: 양쪽 작업 가능하지만 한쪽만 사용
 Array: 메모리 효율적이지만 크기 제한
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>불필요한 상태 관리 피하기</strong></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Bad: 수동 카운트 관리</span>
 <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
 <span class="n">count</span><span class="o">++;</span>
 <span class="n">count</span><span class="o">--;</span>
    
 <span class="c1">// Good: 자료구조의 메서드 활용</span>
 <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Amortized O(1) 이해</strong></p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 각 요청은:
 - 정확히 1번 추가
 - 최대 1번 제거
    
 n개 요청 → 총 2n번 연산 → O(n)
 평균 → O(1) per request
</code></pre></div>    </div>
  </li>
</ol>

<hr />

<h3 id="핵심-개념">핵심 개념</h3>

<p><strong>슬라이딩 윈도우(Sliding Window)</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>고정된 범위를 유지하며 이동
- 범위 밖 = 제거
- 새 요청 = 추가
</code></pre></div></div>

<p><strong>Queue의 특성</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FIFO (First In First Out)
- 오래된 요청이 앞에
- 새 요청이 뒤에
→ 자연스럽게 시간 순서 유지
</code></pre></div></div>

<hr />

<h2 id="-개선-후-코드">🎯 개선 후 코드</h2>

<p><strong>추천: Queue 방식</strong> (가장 간결하고 명확)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecentCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">requests</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">RecentCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">requests</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ping</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 새 요청 추가</span>
        <span class="n">requests</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        
        <span class="c1">// 3000ms 이전의 요청들 제거</span>
        <span class="c1">// t는 항상 증가하므로 앞에서만 제거</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">requests</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">3000</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">requests</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="c1">// 현재 윈도우 내 요청 수</span>
        <span class="k">return</span> <span class="n">requests</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 시간복잡도: O(1) amortized
 * 공간복잡도: O(W) where W ≤ 3000
 * 
 * Runtime: 18-20ms (상위 85%)
 * Memory: 54MB
 */</span>
</code></pre></div></div>

<p><strong>개선 효과</strong>:</p>

<ul>
  <li>✅ 24ms → 18ms (약 <strong>25% 빠름</strong>)</li>
  <li>✅ 불필요한 while 루프 제거</li>
  <li>✅ 불필요한 변수 3개 제거</li>
  <li>✅ 코드 길이 절반으로 감소</li>
  <li>✅ 가독성 대폭 향상</li>
</ul>

<hr />

<h2 id="-관련-개념">📚 관련 개념</h2>

<h3 id="알고리즘-패턴">알고리즘 패턴</h3>

<ul>
  <li><strong>슬라이딩 윈도우(Sliding Window)</strong></li>
  <li><strong>큐(Queue) 활용</strong></li>
  <li><strong>시계열 데이터 처리</strong></li>
</ul>

<h3 id="연관-개념">연관 개념</h3>

<ol>
  <li>
    <p><strong>시간 윈도우 문제</strong></p>

    <ul>
      <li>최근 N초 내 이벤트</li>
      <li>이동 평균(Moving Average)</li>
      <li>속도 제한(Rate Limiting)</li>
    </ul>
  </li>
  <li>
    <p><strong>실무 활용</strong></p>

    <ul>
      <li><strong>API Rate Limiting</strong>: 분당 요청 수 제한</li>
      <li><strong>로그 분석</strong>: 최근 N분간 에러 수</li>
      <li><strong>모니터링</strong>: 실시간 메트릭 집계</li>
      <li><strong>게임</strong>: 스킬 쿨다운 관리</li>
      <li><strong>네트워크</strong>: 패킷 전송률 계산</li>
    </ul>
  </li>
  <li>
    <p><strong>관련 자료구조</strong></p>

    <ul>
      <li>Circular Buffer</li>
      <li>Time Series Database</li>
      <li>Sliding Window Counter</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="-다음-단계">🎓 다음 단계</h2>

<h3 id="비슷한-문제">비슷한 문제</h3>

<ol>
  <li>
    <p><strong><a href="https://leetcode.com/problems/moving-average-from-data-stream/">LeetCode 346. Moving Average from Data Stream</a></strong> ⭐ (Premium)</p>

    <ul>
      <li>슬라이딩 윈도우로 평균 계산</li>
    </ul>
  </li>
  <li>
    <p><strong><a href="https://leetcode.com/problems/design-hit-counter/">LeetCode 362. Design Hit Counter</a></strong> ⭐⭐ (Premium)</p>

    <ul>
      <li>최근 5분간 히트 수 계산</li>
    </ul>
  </li>
  <li>
    <p><strong><a href="https://leetcode.com/problems/design-snake-game/">LeetCode 353. Design Snake Game</a></strong> ⭐⭐ (Premium)</p>

    <ul>
      <li>Queue로 뱀의 몸 관리</li>
    </ul>
  </li>
  <li>
    <p><strong><a href="https://leetcode.com/problems/sliding-window-maximum/">LeetCode 239. Sliding Window Maximum</a></strong> ⭐⭐⭐⭐</p>

    <ul>
      <li>슬라이딩 윈도우 + Deque</li>
    </ul>
  </li>
  <li>
    <p><strong><a href="https://leetcode.com/problems/first-unique-number/">LeetCode 1429. First Unique Number</a></strong> ⭐⭐ (Premium)</p>

    <ul>
      <li>Queue + HashSet</li>
    </ul>
  </li>
</ol>

<h3 id="심화-학습">심화 학습</h3>

<ol>
  <li><strong>Rate Limiter 구현</strong>: Token Bucket, Leaky Bucket</li>
  <li><strong>Time Series 데이터베이스</strong> 동작 원리</li>
  <li><strong>Circular Buffer</strong> 구현</li>
</ol>

<hr />

<h3 id="연습-포인트-체크리스트">연습 포인트 체크리스트</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Queue 버전으로 재구현</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Moving Average 문제 풀기</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />배열 기반으로 최적화</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Rate Limiter 구현해보기</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />멀티스레드 환경 고려 (synchronized)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />시간 복잡도 증명 작성</li>
</ul>

<hr />

<h2 id="-동작-시각화">🔍 동작 시각화</h2>

<h3 id="상세-예시">상세 예시</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RecentCounter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RecentCounter</span><span class="o">();</span>

<span class="n">ping</span><span class="o">(</span><span class="mi">1</span><span class="o">):</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span>
  <span class="nl">range:</span> <span class="o">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">3000</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">2999</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
  <span class="nl">count:</span> <span class="mi">1</span>

<span class="n">ping</span><span class="o">(</span><span class="mi">100</span><span class="o">):</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">]</span>
  <span class="nl">range:</span> <span class="o">[</span><span class="mi">100</span><span class="o">-</span><span class="mi">3000</span><span class="o">,</span> <span class="mi">100</span><span class="o">]</span> <span class="o">=</span> <span class="o">[-</span><span class="mi">2900</span><span class="o">,</span> <span class="mi">100</span><span class="o">]</span>
  <span class="nl">count:</span> <span class="mi">2</span>

<span class="n">ping</span><span class="o">(</span><span class="mi">3001</span><span class="o">):</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">3001</span><span class="o">]</span>
  <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">3001</span><span class="o">-</span><span class="mi">3000</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">→</span> <span class="mi">1</span> <span class="n">제거</span><span class="o">!</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">100</span><span class="o">,</span> <span class="mi">3001</span><span class="o">]</span>
  <span class="nl">range:</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3001</span><span class="o">]</span>
  <span class="nl">count:</span> <span class="mi">2</span>

<span class="n">ping</span><span class="o">(</span><span class="mi">3002</span><span class="o">):</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">100</span><span class="o">,</span> <span class="mi">3001</span><span class="o">,</span> <span class="mi">3002</span><span class="o">]</span>
  <span class="mi">100</span> <span class="o">&gt;=</span> <span class="mi">3002</span><span class="o">-</span><span class="mi">3000</span> <span class="o">=</span> <span class="mi">2</span> <span class="err">→</span> <span class="n">유지</span>
  <span class="nl">range:</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3002</span><span class="o">]</span>
  <span class="nl">count:</span> <span class="mi">3</span>

<span class="n">ping</span><span class="o">(</span><span class="mi">6000</span><span class="o">):</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">100</span><span class="o">,</span> <span class="mi">3001</span><span class="o">,</span> <span class="mi">3002</span><span class="o">,</span> <span class="mi">6000</span><span class="o">]</span>
  <span class="mi">100</span> <span class="o">&lt;</span> <span class="mi">3000</span> <span class="err">→</span> <span class="n">제거</span>
  <span class="mi">3001</span> <span class="o">&lt;</span> <span class="mi">3000</span> <span class="err">→</span> <span class="n">제거</span>
  <span class="mi">3002</span> <span class="o">&lt;</span> <span class="mi">3000</span> <span class="err">→</span> <span class="n">제거</span>
  <span class="nl">queue:</span> <span class="o">[</span><span class="mi">6000</span><span class="o">]</span>
  <span class="nl">range:</span> <span class="o">[</span><span class="mi">3000</span><span class="o">,</span> <span class="mi">6000</span><span class="o">]</span>
  <span class="nl">count:</span> <span class="mi">1</span>
</code></pre></div></div>

<hr />

<h2 id="-원본-코드의-문제점-상세-분석">💭 원본 코드의 문제점 상세 분석</h2>

<h3 id="1-불필요한-뒤쪽-제거-로직">1. 불필요한 뒤쪽 제거 로직</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ 절대 실행되지 않는 코드</span>
<span class="k">while</span><span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">deque</span><span class="o">.</span><span class="na">peekLast</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">){</span>
    <span class="n">deque</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
    <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>왜 실행 안 되나?</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>  <span class="c1">// 방금 t를 추가했음</span>
<span class="c1">// deque.peekLast() == t</span>
<span class="c1">// t &gt; t는 항상 false!</span>
</code></pre></div></div>

<p><strong>증명</strong>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">t</code>는 항상 증가 (문제 조건: strictly increasing)</li>
  <li><code class="language-plaintext highlighter-rouge">deque.peekLast()</code>는 가장 최근에 추가된 값</li>
  <li>가장 최근 값 = 현재 <code class="language-plaintext highlighter-rouge">t</code></li>
  <li>따라서 <code class="language-plaintext highlighter-rouge">deque.peekLast() &gt; t</code>는 항상 거짓</li>
</ul>

<hr />

<h3 id="2-불필요한-count-관리">2. 불필요한 count 관리</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bad</span>
<span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
<span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
<span class="n">count</span><span class="o">++;</span>
<span class="n">deque</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
<span class="n">count</span><span class="o">--;</span>
<span class="k">return</span> <span class="n">count</span><span class="o">;</span>

<span class="c1">// Good</span>
<span class="n">deque</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
<span class="n">deque</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
<span class="k">return</span> <span class="n">deque</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>  <span class="c1">// 자동 관리!</span>
</code></pre></div></div>

<hr />

<h2 id="️-keywords">🏷️ Keywords</h2>

<p>#Queue #SlidingWindow #TimeWindow #DataStream #FIFO #Deque #슬라이딩윈도우 #시계열데이터 #RateLimiting #RecentCounter #AmortizedO1 #EventProcessing #LeetCodeEasy #코딩테스트 #실시간처리 #윈도우관리</p>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 yunYoung e. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
