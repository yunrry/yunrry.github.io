# LeetCode 300: Longest Increasing Subsequence

## ğŸ“Š ê²°ê³¼
- **ì†Œìš”ì‹œê°„:** (ê¸°ë¡ í•„ìš”)
- **ê²°ê³¼:** í†µê³¼
- **Runtime:** 38ms
- **Memory:** 45.88MB

## ğŸ’» ë‚´ ì½”ë“œ (Try 1)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int max = 1;
               
        for(int i=1; i<nums.length; i++){
            for(int j=0; j<i; j++){
                if(nums[i]>nums[j]){
                    dp[i]=Math.max(dp[i], dp[j]+1);
                }
            }
            max = Math.max(max, dp[i]);
        }

        return max;
    }
}
```

## ğŸ“ í‰ê°€

### âœ” ì˜í•œ ì 

1. **O(NÂ²) DP ì •í™•íˆ êµ¬í˜„**
   - `dp[i]` = ië²ˆì§¸ê¹Œì§€ì˜ LIS ê¸¸ì´
   - ì´ì „ ëª¨ë“  ì›ì†Œì™€ ë¹„êµ

2. **ì´ˆê¸°í™” ì ì ˆ**
   - `Arrays.fill(dp, 1)` - ìµœì†Œ ê¸¸ì´ 1

3. **ìµœëŒ“ê°’ ì¶”ì **
   - ë£¨í”„ ì¤‘ max ê°±ì‹ 

---

## âœ¦ ê°œì„ ì 

### 1. ì‹œê°„ë³µì¡ë„ O(NÂ²)

í˜„ì¬ ë°©ì‹ì€ ëª¨ë“  ì´ì „ ì›ì†Œë¥¼ í™•ì¸í•œë‹¤. Binary Searchë¡œ O(N log N) ê°€ëŠ¥í•˜ë‹¤.

### 2. max ê°±ì‹  ìœ„ì¹˜

```java
// âœ˜ ë§¤ iterationë§ˆë‹¤ ê°±ì‹ 
for(int i=1; i<nums.length; i++){
    // ...
    max = Math.max(max, dp[i]);
}

// âœ” ë§ˆì§€ë§‰ì— í•œ ë²ˆë§Œ
return Arrays.stream(dp).max().getAsInt();
```

---

## âœ¨ ìµœì í™”ëœ í’€ì´

### ë°©ë²• 1: O(N log N) - Binary Search

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        List<Integer> tails = new ArrayList<>();
        
        for(int num : nums){
            int pos = Collections.binarySearch(tails, num);
            if(pos < 0) pos = -(pos + 1);
            
            if(pos == tails.size()){
                tails.add(num);
            } else {
                tails.set(pos, num);
            }
        }
        
        return tails.size();
    }
}
```

**í•µì‹¬ ì•„ì´ë””ì–´:**
- `tails[i]` = ê¸¸ì´ i+1ì¸ LISì˜ ë§ˆì§€ë§‰ ì›ì†Œ ì¤‘ ìµœì†Ÿê°’
- ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°

### ë°©ë²• 2: O(NÂ²) ê°œì„ 

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        
        for(int i=1; i<nums.length; i++){
            for(int j=0; j<i; j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        return Arrays.stream(dp).max().getAsInt();
    }
}
```

---

## ì„±ëŠ¥ ë¹„êµ

| ë°©ë²• | ì‹œê°„ë³µì¡ë„ | ê³µê°„ë³µì¡ë„ | Runtime |
|------|----------|-----------|---------|
| **ì›ë³¸ (DP)** | O(NÂ²) | O(N) | 38ms |
| **Binary Search** | O(N log N) | O(N) | ~5ms |

---

## ğŸ’¡ í•µì‹¬ ì¸ì‚¬ì´íŠ¸

### DP ì í™”ì‹

```
dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]
```

### Binary Search ì›ë¦¬

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

tails ë³€í™”:
[10]
[9]
[2]
[2, 5]
[2, 3]
[2, 3, 7]
[2, 3, 7, 101]
[2, 3, 7, 18]
â†’ LIS ê¸¸ì´ = 4
```

`tails`ëŠ” ì‹¤ì œ LISê°€ ì•„ë‹ˆë¼, ê° ê¸¸ì´ì˜ ìµœì  í›„ë³´ë‹¤.

---
## Collections.binarySearch()

### ê¸°ë³¸ ì‚¬ìš©ë²•

```java
int pos = Collections.binarySearch(List<T> list, T key);
```

### ë°˜í™˜ê°’

**ì–‘ìˆ˜ (â‰¥0):** ì°¾ì€ ì¸ë±ìŠ¤
```java
List<Integer> list = Arrays.asList(1, 3, 5, 7, 9);
int pos = Collections.binarySearch(list, 5);  // pos = 2
```

**ìŒìˆ˜ (<0):** ëª» ì°¾ìŒ â†’ ì‚½ì… ìœ„ì¹˜ ê³„ì‚° í•„ìš”
```java
int pos = Collections.binarySearch(list, 6);  // pos = -4
int insertPos = -(pos + 1);  // insertPos = 3
```

### ì‚½ì… ìœ„ì¹˜ ê³µì‹

```
insertPos = -(returnValue + 1)
```

### ì˜ˆì‹œ

```java
List<Integer> tails = new ArrayList<>();
// tails = [2, 3, 7]

int pos = Collections.binarySearch(tails, 5);
// pos = -3 (5ëŠ” ì¸ë±ìŠ¤ 2ì— ë“¤ì–´ê°€ì•¼ í•¨)

pos = -(pos + 1);  // pos = 2
tails.set(2, 5);  // [2, 3, 5]
```

### LISì—ì„œ í™œìš©

```java
for(int num : nums){
    int pos = Collections.binarySearch(tails, num);
    
    // ëª» ì°¾ìœ¼ë©´ ì‚½ì… ìœ„ì¹˜ ê³„ì‚°
    if(pos < 0) pos = -(pos + 1);
    
    // ëì— ì¶”ê°€ or ê¸°ì¡´ ê°’ êµì²´
    if(pos == tails.size()){
        tails.add(num);
    } else {
        tails.set(pos, num);
    }
}
```

### ì£¼ì˜ì‚¬í•­

- **ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸**ì—ì„œë§Œ ì‚¬ìš©
- ì¤‘ë³µê°’ ìˆìœ¼ë©´ ì–´ë–¤ ì¸ë±ìŠ¤ ë°˜í™˜ë ì§€ ë¯¸ì •
- O(log N) ì‹œê°„ë³µì¡ë„
---

## ğŸ“š ê´€ë ¨ ê°œë…

- **DP**: ìµœì  ë¶€ë¶„ êµ¬ì¡°
- **ì´ë¶„ íƒìƒ‰**: ì •ë ¬ëœ ë°°ì—´ì—ì„œ O(log N) íƒìƒ‰
- **Greedy + DP**: tails ë°°ì—´ ìœ ì§€

---

## ğŸ“ ë‹¤ìŒ ë‹¨ê³„

### ìœ ì‚¬ ë¬¸ì œ
1. [LeetCode 673: Number of LIS](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)
2. [LeetCode 354: Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/)
3. [ë°±ì¤€ 11053: ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´](https://www.acmicpc.net/problem/11053)

### ì—°ìŠµ í¬ì¸íŠ¸
- [ ] Binary Search í™œìš© LIS êµ¬í˜„
- [ ] O(NÂ²) â†’ O(N log N) ìµœì í™” ì´í•´
- [ ] LIS ì—­ì¶”ì  (ì‹¤ì œ ìˆ˜ì—´ êµ¬í•˜ê¸°)

---

## ğŸ·ï¸ Keywords
`#LeetCode` `#DP` `#BinarySearch` `#LIS` `#Java` `#ìµœì í™”`