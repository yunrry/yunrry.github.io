<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>자료구조 면접/서술 - Second Brain</title>
<meta name="description" content="2026년 목표: 개발로 월급받기추가 정보 없음">


  <meta name="author" content="yunYoung e">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Second Brain">
<meta property="og:title" content="자료구조 면접/서술">
<meta property="og:url" content="http://0.0.0.0:4000/assets/contents/cs/data-structure-interview/">


  <meta property="og:description" content="2026년 목표: 개발로 월급받기추가 정보 없음">












<link rel="canonical" href="http://0.0.0.0:4000/assets/contents/cs/data-structure-interview/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "yunYoung e",
      "url": "http://0.0.0.0:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Second Brain Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>


  
    <script src="/assets/js/custom.js"></script>
  


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--default">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Second Brain
          <span class="site-subtitle">뇌정리노트</span>
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      <h1 id="자료구조-면접서술">자료구조 면접/서술</h1>

<h2 id="1-스택-2개로-큐-구현">1. 스택 2개로 큐 구현</h2>

<h3 id="-핵심-아이디어">📌 핵심 아이디어</h3>

<p><strong>두 개의 스택(stack1, stack2)을 사용하여 FIFO 동작 구현</strong></p>

<hr />

<h3 id="-동작-원리">💡 동작 원리</h3>

<h3 id="구조">구조</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack1 (enqueue용)    stack2 (dequeue용)
┌─────┐              ┌─────┐
│     │              │     │
│     │              │     │
└─────┘              └─────┘
</code></pre></div></div>

<h3 id="규칙">규칙</h3>
<ol>
  <li><strong>Enqueue</strong>: stack1에 push</li>
  <li><strong>Dequeue</strong>:
    <ul>
      <li>stack2가 비어있으면 → stack1의 모든 원소를 stack2로 이동</li>
      <li>stack2에서 pop</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="-구현-코드-c언어">💻 구현 코드 (C언어)</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_SIZE 100
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Stack</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Stack</span> <span class="n">stack1</span><span class="p">;</span>  <span class="c1">// enqueue용</span>
    <span class="n">Stack</span> <span class="n">stack2</span><span class="p">;</span>  <span class="c1">// dequeue용</span>
<span class="p">}</span> <span class="n">QueueWithStacks</span><span class="p">;</span>

<span class="c1">// 스택 기본 연산</span>
<span class="kt">void</span> <span class="nf">initStack</span><span class="p">(</span><span class="n">Stack</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="n">Stack</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">Stack</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">&gt;=</span> <span class="n">MAX_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="o">++</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pop</span><span class="p">(</span><span class="n">Stack</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span><span class="o">--</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 큐 초기화</span>
<span class="kt">void</span> <span class="nf">initQueue</span><span class="p">(</span><span class="n">QueueWithStacks</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">initStack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack1</span><span class="p">);</span>
    <span class="n">initStack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Enqueue: stack1에 push</span>
<span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="n">QueueWithStacks</span><span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Dequeue: stack2에서 pop</span>
<span class="kt">int</span> <span class="nf">dequeue</span><span class="p">(</span><span class="n">QueueWithStacks</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// stack2가 비어있으면 stack1의 원소를 모두 이동</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack2</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack1</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack1</span><span class="p">);</span>
            <span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack2</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// stack2가 여전히 비어있으면 큐가 빈 것</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack2</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// 에러</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">stack2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="-동작-예시">📊 동작 예시</h2>

<h3 id="예시-1-기본-동작">예시 1: 기본 동작</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기 상태:
stack1: []
stack2: []

1. enqueue(1)
stack1: [1]
stack2: []

2. enqueue(2)
stack1: [1, 2]
stack2: []

3. enqueue(3)
stack1: [1, 2, 3]
stack2: []

4. dequeue() → stack2가 비어있음
   stack1의 모든 원소를 stack2로 이동:
   
   stack1에서 pop: 3, 2, 1 순서로
   stack2에 push: 3, 2, 1 순서로
   
   결과:
   stack1: []
   stack2: [3, 2, 1]  (top이 1)
   
   stack2에서 pop() → 1 반환

5. dequeue() → stack2가 비어있지 않음
   stack2: [3, 2]
   2 반환

6. enqueue(4)
   stack1: [4]
   stack2: [3]

7. dequeue()
   stack2: [3] → 3 반환
   
8. dequeue() → stack2가 비어있음
   stack1의 4를 stack2로 이동
   stack2: [4] → 4 반환
</code></pre></div></div>

<hr />

<h2 id="-시간복잡도-분석">🎯 시간복잡도 분석</h2>

<h3 id="enqueue">Enqueue</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>시간복잡도: O(1)
- stack1에 push만 하면 됨
</code></pre></div></div>

<h3 id="dequeue">Dequeue</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최선의 경우: O(1)
- stack2에 원소가 있으면 바로 pop

최악의 경우: O(N)
- stack2가 비어있어서 stack1의 모든 원소(N개)를 이동

분할 상환 분석 (Amortized): O(1)
- 각 원소는 최대 2번만 이동 (stack1→stack2, stack2에서 pop)
- N번의 연산에 대해 총 2N번의 작업 → O(1)
</code></pre></div></div>

<hr />

<h2 id="-면접-답변-예시">💬 면접 답변 예시</h2>

<h3 id="짧은-답변">짧은 답변</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>두 개의 스택을 사용합니다.
- stack1은 enqueue 전용
- stack2는 dequeue 전용

Enqueue 시 stack1에 push하고,
Dequeue 시 stack2가 비어있으면 stack1의 모든 원소를 
stack2로 옮긴 후 pop합니다.

이렇게 하면 FIFO 순서가 보장됩니다.
</code></pre></div></div>

<h3 id="상세-답변">상세 답변</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>스택은 LIFO 구조인데, 두 개를 사용하면 큐의 FIFO를 구현할 수 있습니다.

동작 원리:
1. Enqueue는 항상 stack1에 push
2. Dequeue는 stack2에서 pop
   - stack2가 비어있으면 stack1의 모든 원소를 뒤집어서 이동

왜 동작하는가?
- stack1에서 stack2로 이동할 때 순서가 뒤집힙니다
- 두 번 뒤집으면 원래 순서로 복원됩니다
- 따라서 먼저 들어온 원소가 먼저 나갑니다

시간복잡도:
- Enqueue: O(1)
- Dequeue: 분할 상환 O(1)
  (최악의 경우 O(N)이지만, 각 원소는 최대 2번만 이동)

공간복잡도: O(N) (두 스택 합쳐서)
</code></pre></div></div>

<hr />

<h1 id="2-hashmap-동작-원리">2. HashMap 동작 원리</h1>

<h2 id="-hashmap이란">📌 HashMap이란?</h2>

<p><strong>Key-Value 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 평균 O(1)의 검색/삽입/삭제 성능 제공</strong></p>

<hr />

<h2 id="-동작-원리-1">💡 동작 원리</h2>

<h3 id="1-기본-구조">1. 기본 구조</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HashMap 내부:
┌─────────────────┐
│ 배열 (Bucket)    │
├─────────────────┤
│ [0] → NULL      │
│ [1] → NULL      │
│ [2] → (k3, v3)  │
│ [3] → NULL      │
│ [4] → (k1, v1)  │
│ [5] → NULL      │
│ [6] → (k2, v2)  │
│ [7] → NULL      │
└─────────────────┘
</code></pre></div></div>

<h3 id="2-해시-함수">2. 해시 함수</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hash(key) → index

예시:
key = "apple"
hash("apple") = 12345
index = 12345 % 8 = 5

→ 배열의 5번 인덱스에 저장
</code></pre></div></div>

<hr />

<h2 id="-주요-연산">🔧 주요 연산</h2>

<h3 id="1-put-삽입">1. Put (삽입)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1. 해시 코드 계산</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
    
    <span class="c1">// 2. 배열 인덱스 계산</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">buckets</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    
    <span class="c1">// 3. 해당 인덱스에 저장</span>
    <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-get-조회">2. Get (조회)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1. 해시 코드 계산</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
    
    <span class="c1">// 2. 배열 인덱스 계산</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">buckets</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    
    <span class="c1">// 3. 해당 인덱스에서 값 반환</span>
    <span class="nc">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="k">return</span> <span class="n">entry</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">entry</span><span class="o">.</span><span class="na">value</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="️-해시-충돌-hash-collision">⚠️ 해시 충돌 (Hash Collision)</h2>

<h3 id="충돌이란">충돌이란?</h3>

<p><strong>서로 다른 키가 같은 인덱스를 가리키는 현상</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hash("apple") % 8 = 5
hash("banana") % 8 = 5  ← 충돌!

둘 다 인덱스 5를 가리킴
</code></pre></div></div>

<hr />

<h2 id="️-해시-충돌-해결-방법">🛠️ 해시 충돌 해결 방법</h2>

<h3 id="방법-1-체이닝-chaining-">방법 1: 체이닝 (Chaining) ⭐</h3>

<p><strong>같은 인덱스에 여러 원소를 연결 리스트로 저장</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bucket 배열:
[0] → NULL
[1] → NULL
[2] → (k3, v3) → NULL
[3] → NULL
[4] → NULL
[5] → (apple, 100) → (banana, 200) → NULL  ← 연결 리스트
[6] → (k2, v2) → NULL
[7] → NULL
</code></pre></div></div>

<h4 id="구현-java">구현 (Java)</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>  <span class="c1">// 연결 리스트</span>
        
        <span class="nc">Entry</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">buckets</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        
        <span class="c1">// 이미 키가 존재하는지 확인</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">entry</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>  <span class="c1">// 값 업데이트</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 새 노드를 맨 앞에 삽입</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">newEntry</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Entry</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="n">newEntry</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">newEntry</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        
        <span class="c1">// 연결 리스트 순회</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">// 못 찾음</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="시간복잡도">시간복잡도</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>평균: O(1)
- 충돌이 적으면 연결 리스트 길이가 짧음

최악: O(N)
- 모든 원소가 한 인덱스에 몰림
- 연결 리스트를 끝까지 순회

실제로는:
- Java 8+: 연결 리스트 길이가 8 이상이면 Red-Black Tree로 변환
- 최악의 경우 O(log N)으로 개선
</code></pre></div></div>

<hr />

<h3 id="방법-2-개방-주소법-open-addressing">방법 2: 개방 주소법 (Open Addressing)</h3>

<p><strong>충돌 시 다른 빈 버킷을 찾아 저장</strong></p>

<h4 id="2-1-선형-탐사-linear-probing">2-1. 선형 탐사 (Linear Probing)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>충돌 시 바로 다음 인덱스 확인

index = hash(key) % size
충돌 시: (index + 1) % size
또 충돌: (index + 2) % size
...

예시:
hash("apple") % 8 = 5
[5]가 차있음 → [6] 확인
[6]이 차있음 → [7] 확인
[7]이 비어있음 → 저장!
</code></pre></div></div>

<p><strong>문제점: 클러스터링 (Clustering)</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[3][4][5][6][7] 모두 차있으면
다음 삽입도 이 영역에 몰림 → 성능 저하
</code></pre></div></div>

<h4 id="2-2-제곱-탐사-quadratic-probing">2-2. 제곱 탐사 (Quadratic Probing)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>충돌 시 제곱수만큼 이동

index = hash(key) % size
충돌 시: (index + 1²) % size = (index + 1) % size
또 충돌: (index + 2²) % size = (index + 4) % size
또 충돌: (index + 3²) % size = (index + 9) % size

클러스터링 완화 ✔
</code></pre></div></div>

<h4 id="2-3-이중-해싱-double-hashing">2-3. 이중 해싱 (Double Hashing)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>두 개의 해시 함수 사용

index = hash1(key) % size
충돌 시: (index + hash2(key)) % size
또 충돌: (index + 2 * hash2(key)) % size

최소 클러스터링 ✔
</code></pre></div></div>

<hr />

<h2 id="-체이닝-vs-개방-주소법-비교">📊 체이닝 vs 개방 주소법 비교</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>체이닝</th>
      <th>개방 주소법</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>구현</strong></td>
      <td>간단 ✔</td>
      <td>복잡</td>
    </tr>
    <tr>
      <td><strong>메모리</strong></td>
      <td>추가 메모리 (포인터)</td>
      <td>배열만 사용 ✔</td>
    </tr>
    <tr>
      <td><strong>캐시 효율</strong></td>
      <td>낮음 (포인터 추적)</td>
      <td>높음 (연속 메모리) ✔</td>
    </tr>
    <tr>
      <td><strong>삭제</strong></td>
      <td>쉬움 ✔</td>
      <td>복잡 (재배치 필요)</td>
    </tr>
    <tr>
      <td><strong>로드팩터</strong></td>
      <td>1 이상 가능 ✔</td>
      <td>1 미만만 가능</td>
    </tr>
    <tr>
      <td><strong>최악 성능</strong></td>
      <td>O(N), Java 8+는 O(log N)</td>
      <td>O(N)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-리사이징-resizing">🔄 리사이징 (Resizing)</h2>

<h3 id="로드-팩터-load-factor">로드 팩터 (Load Factor)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>로드 팩터 = (저장된 원소 수) / (버킷 크기)

예: 16개 버킷에 12개 원소 저장
→ 로드 팩터 = 12/16 = 0.75
</code></pre></div></div>

<h3 id="리사이징-기준">리사이징 기준</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Java HashMap:
- 기본 로드 팩터: 0.75
- 로드 팩터 초과 시 → 버킷 크기 2배 확장

예: 16 → 32 → 64 → 128 ...
</code></pre></div></div>

<h3 id="리사이징-과정">리사이징 과정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 새로운 큰 배열 생성 (2배 크기)
2. 모든 원소를 새 배열로 재배치 (rehashing)
   - 해시값은 동일하지만 인덱스가 변경됨
   - index = hash % newSize

시간복잡도: O(N)
- 모든 원소를 다시 삽입해야 함

분할 상환: O(1)
- 리사이징은 가끔만 발생
</code></pre></div></div>

<hr />

<h2 id="-면접-답변-예시-1">💬 면접 답변 예시</h2>

<h3 id="짧은-답변-1">짧은 답변</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HashMap은 해시 함수로 키를 배열 인덱스로 변환하여
평균 O(1)에 데이터를 저장/조회합니다.

충돌 발생 시:
1. 체이닝: 같은 인덱스에 연결 리스트로 저장
2. 개방 주소법: 다른 빈 버킷을 찾아 저장

Java는 체이닝 방식을 사용하며,
로드 팩터가 0.75 초과 시 배열 크기를 2배로 확장합니다.
</code></pre></div></div>

<h3 id="상세-답변-1">상세 답변</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HashMap 동작 원리:

1. 데이터 저장:
   - 키의 hashCode() 호출
   - 해시값을 배열 크기로 나눈 나머지가 인덱스
   - 해당 인덱스에 (key, value) 저장

2. 해시 충돌 해결:
   
   체이닝 (Java 사용):
   - 같은 인덱스에 연결 리스트로 저장
   - Java 8+: 리스트 길이 8 이상이면 Red-Black Tree 변환
   - 최악 O(N) → O(log N)으로 개선
   
   개방 주소법:
   - 선형 탐사: 다음 인덱스 순차 확인
   - 제곱 탐사: 제곱수만큼 이동
   - 이중 해싱: 두 번째 해시 함수 사용

3. 리사이징:
   - 로드 팩터(원소수/버킷크기)가 임계값(0.75) 초과 시
   - 배열 크기를 2배로 확장
   - 모든 원소를 재배치 (rehashing)

시간복잡도:
- 평균: O(1)
- 최악: O(N) (체이닝), O(log N) (Java 8+ 트리화)

공간복잡도: O(N)
</code></pre></div></div>

<hr />

<h1 id="3-bst-vs-avl-tree-vs-red-black-tree">3. BST vs AVL Tree vs Red-Black Tree</h1>

<h2 id="-비교-표">📊 비교 표</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>BST</th>
      <th>AVL Tree</th>
      <th>Red-Black Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>균형</strong></td>
      <td>없음</td>
      <td>엄격한 균형</td>
      <td>느슨한 균형</td>
    </tr>
    <tr>
      <td><strong>높이</strong></td>
      <td>최악 O(N)</td>
      <td>최대 1.44 log N</td>
      <td>최대 2 log N</td>
    </tr>
    <tr>
      <td><strong>탐색</strong></td>
      <td>최악 O(N)</td>
      <td><strong>O(log N)</strong></td>
      <td><strong>O(log N)</strong></td>
    </tr>
    <tr>
      <td><strong>삽입</strong></td>
      <td>평균 O(log N)</td>
      <td>O(log N), 회전 많음</td>
      <td><strong>O(log N), 회전 적음</strong></td>
    </tr>
    <tr>
      <td><strong>삭제</strong></td>
      <td>평균 O(log N)</td>
      <td>O(log N), 회전 많음</td>
      <td><strong>O(log N), 회전 적음</strong></td>
    </tr>
    <tr>
      <td><strong>회전 빈도</strong></td>
      <td>없음</td>
      <td>높음 (2회전 이내)</td>
      <td>낮음 (3회전 이내)</td>
    </tr>
    <tr>
      <td><strong>사용 사례</strong></td>
      <td>단순 구현</td>
      <td>검색 많음</td>
      <td>삽입/삭제 많음</td>
    </tr>
    <tr>
      <td><strong>구현</strong></td>
      <td>간단 ✔</td>
      <td>복잡</td>
      <td>매우 복잡</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="1️⃣-bst-binary-search-tree">1️⃣ BST (Binary Search Tree)</h2>

<h3 id="특징">특징</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 왼쪽 &lt; 루트 &lt; 오른쪽
✘ 균형 보장 없음
✘ 편향 트리 가능
</code></pre></div></div>

<h3 id="구조-예시">구조 예시</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>균형 잡힌 BST:
         50
        /  \
      30    70
     / \    / \
   20  40 60  80

높이: 3
탐색: O(log N) ✔

편향된 BST (최악):
    10
      \
       20
         \
          30
            \
             40
              \
               50

높이: 5
탐색: O(N) ✘ (연결 리스트와 동일)
</code></pre></div></div>

<h3 id="장단점">장단점</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
✔ 구현이 간단
✔ 평균적으로 O(log N) 성능
✔ 중위 순회 시 정렬된 결과

단점:
✘ 최악의 경우 O(N)
✘ 순차 삽입 시 편향 트리
✘ 균형 보장 없음
</code></pre></div></div>

<hr />

<h2 id="2️⃣-avl-tree">2️⃣ AVL Tree</h2>

<h3 id="특징-1">특징</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 자가 균형 이진 탐색 트리
✔ 모든 노드의 BF (Balance Factor) ∈ {-1, 0, 1}
✔ 가장 엄격한 균형 조건

BF = (왼쪽 서브트리 높이) - (오른쪽 서브트리 높이)
</code></pre></div></div>

<h3 id="균형-인수-예시">균형 인수 예시</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 균형 잡힌 AVL:
         50 (BF=0)
        /  \
      30    70 (BF=0)
     / \      \
   20  40     80

✘ 불균형 (BF=2):
         50 (BF=2)
        /
      30 (BF=1)
     /
   20

→ 회전 필요!
</code></pre></div></div>

<h3 id="회전-종류">회전 종류</h3>

<h4 id="ll-회전-right-rotation">LL 회전 (Right Rotation)</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    30             20
   /       →      /  \
  20             10   30
 /
10
</code></pre></div></div>

<h4 id="rr-회전-left-rotation">RR 회전 (Left Rotation)</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10                 20
  \       →       /  \
   20           10   30
     \
      30
</code></pre></div></div>

<h4 id="lr-회전-left-right">LR 회전 (Left-Right)</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  30           30           20
 /      →     /      →     /  \
10           20           10   30
  \         /
   20      10
</code></pre></div></div>

<h4 id="rl-회전-right-left">RL 회전 (Right-Left)</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10           10            20
  \    →       \     →    /  \
   30           20       10   30
  /              \
20               30
</code></pre></div></div>

<h3 id="장단점-1">장단점</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
✔ 항상 O(log N) 보장
✔ 검색 성능이 가장 우수
✔ 높이가 가장 낮음 (최대 1.44 log N)

단점:
✘ 삽입/삭제 시 회전 빈번
✘ 구현 복잡
✘ 오버헤드 (BF 저장)
</code></pre></div></div>

<h3 id="사용-사례">사용 사례</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 데이터베이스 인덱스 (검색 중심)
✔ 읽기 작업이 99%
✔ 실시간 시스템 (예측 가능한 성능)
</code></pre></div></div>

<hr />

<h2 id="3️⃣-red-black-tree">3️⃣ Red-Black Tree</h2>

<h3 id="특징-2">특징</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 자가 균형 이진 탐색 트리
✔ 각 노드는 빨강 또는 검정
✔ AVL보다 느슨한 균형
✔ 회전 빈도 낮음
</code></pre></div></div>

<h3 id="규칙-5가지">규칙 (5가지)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 모든 노드는 빨강 또는 검정
2. 루트는 검정
3. 모든 리프(NULL)는 검정
4. 빨강 노드의 자식은 검정
   (빨강-빨강 연속 불가)
5. 모든 경로의 검정 노드 수 동일
   (Black Height 일정)
</code></pre></div></div>

<h3 id="구조-예시-1">구조 예시</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       [20B]
      /     \
   [10R]   [30B]
   /  \     /  \
[5B] [15B] [25R] [40B]

B = Black, R = Red

규칙 확인:
✔ 루트(20)는 검정
✔ 빨강 노드(10, 25)의 자식은 검정
✔ 모든 경로의 검정 노드 수 = 3
</code></pre></div></div>

<h3 id="회전-및-색-변경">회전 및 색 변경</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>삽입/삭제 시:
1. BST 규칙대로 삽입/삭제
2. 새 노드는 빨강으로 삽입
3. Red-Black 규칙 위반 시:
   - 색 변경 (Recoloring)
   - 회전 (Rotation)
</code></pre></div></div>

<h3 id="장단점-2">장단점</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
✔ 삽입/삭제가 AVL보다 빠름
✔ 회전 횟수 적음 (최대 3회)
✔ 최악의 경우도 O(log N)
✔ 실무에서 가장 많이 사용

단점:
✘ AVL보다 높이가 높음 (최대 2 log N)
✘ 검색이 AVL보다 약간 느림
✘ 구현이 매우 복잡
</code></pre></div></div>

<h3 id="사용-사례-1">사용 사례</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ Java TreeMap, TreeSet
✔ C++ STL map, set
✔ Linux 커널 (프로세스 스케줄링)
✔ 삽입/삭제가 빈번한 경우
</code></pre></div></div>

<hr />

<h2 id="-상세-비교">🎯 상세 비교</h2>

<h3 id="1-높이-비교">1. 높이 비교</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>같은 N개 노드 저장 시:

BST 높이:
- 평균: 1.39 log N
- 최악: N (편향 트리)

AVL 높이:
- 최대: 1.44 log N ✔ (가장 낮음)

Red-Black 높이:
- 최대: 2 log N
</code></pre></div></div>

<h3 id="2-연산-비교">2. 연산 비교</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1000개 노드 기준:

        | BST     | AVL      | RB-Tree
--------|---------|----------|----------
검색    | 평균 10 | 최대 14  | 최대 20
        | 최악 1000| ✔       |
삽입    | 평균 10 | 14(회전) | 20(회전적음) ✔
삭제    | 평균 10 | 14(회전) | 20(회전적음) ✔
</code></pre></div></div>

<h3 id="3-회전-빈도">3. 회전 빈도</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>삽입 1000번 기준:

AVL Tree: 평균 500번 회전
Red-Black: 평균 200번 회전 ✔

→ RB-Tree가 삽입/삭제에 유리
</code></pre></div></div>

<hr />

<h2 id="-면접-답변-예시-2">💬 면접 답변 예시</h2>

<h3 id="짧은-답변-2">짧은 답변</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BST: 기본 이진 탐색 트리, 균형 보장 없음

AVL: 엄격한 균형 유지, 검색 최적화
- BF가 항상 -1, 0, 1
- 높이가 가장 낮음
- 검색이 많을 때 사용

Red-Black: 느슨한 균형, 삽입/삭제 최적화
- 빨강/검정 노드로 균형 유지
- 회전 빈도 낮음
- 실무에서 가장 많이 사용 (Java TreeMap 등)
</code></pre></div></div>

<h3 id="상세-답변-2">상세 답변</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. BST (Binary Search Tree):
   - 왼쪽 &lt; 루트 &lt; 오른쪽 규칙만 유지
   - 균형 보장 없어서 편향 트리 가능
   - 최악의 경우 O(N)
   - 구현은 간단하지만 실무에선 잘 안 씀

2. AVL Tree:
   - 모든 노드의 Balance Factor가 -1, 0, 1
   - 가장 엄격한 균형 조건
   - 높이가 최대 1.44 log N (가장 낮음)
   - 검색 성능이 최고
   - 하지만 삽입/삭제 시 회전이 빈번
   - 사용 사례: 데이터베이스 인덱스 (검색 중심)

3. Red-Black Tree:
   - 빨강/검정 노드로 균형 유지
   - 5가지 규칙 (루트는 검정, 빨강-빨강 연속 불가 등)
   - 높이가 최대 2 log N (AVL보다 높음)
   - 하지만 회전 빈도가 낮아 삽입/삭제가 빠름
   - 실무에서 가장 많이 사용
   - 사용 사례: Java TreeMap, C++ map, Linux 커널

선택 기준:
- 검색이 99% → AVL Tree
- 삽입/삭제가 빈번 → Red-Black Tree
- 단순 구현 → BST (실무에선 거의 안 씀)
</code></pre></div></div>

<hr />

<h1 id="4-array-vs-arraylist-vs-linkedlist">4. Array vs ArrayList vs LinkedList</h1>

<hr />

<h2 id="-비교-표-1">📊 비교 표</h2>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>Array</th>
      <th>ArrayList</th>
      <th>LinkedList</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>타입</strong></td>
      <td>기본 자료구조</td>
      <td>동적 배열</td>
      <td>이중 연결 리스트</td>
    </tr>
    <tr>
      <td><strong>크기</strong></td>
      <td>고정 ✘</td>
      <td>동적 ✔</td>
      <td>동적 ✔</td>
    </tr>
    <tr>
      <td><strong>메모리</strong></td>
      <td>연속적</td>
      <td>연속적</td>
      <td>비연속적</td>
    </tr>
    <tr>
      <td><strong>인덱스 접근</strong></td>
      <td>O(1) ✔</td>
      <td>O(1) ✔</td>
      <td>O(N) ✘</td>
    </tr>
    <tr>
      <td><strong>검색</strong></td>
      <td>O(N)</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td><strong>맨앞 삽입</strong></td>
      <td>-</td>
      <td>O(N) ✘</td>
      <td>O(1) ✔</td>
    </tr>
    <tr>
      <td><strong>맨뒤 삽입</strong></td>
      <td>-</td>
      <td>O(1) (분할상환)</td>
      <td>O(1) ✔</td>
    </tr>
    <tr>
      <td><strong>중간 삽입</strong></td>
      <td>-</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td><strong>맨앞 삭제</strong></td>
      <td>-</td>
      <td>O(N) ✘</td>
      <td>O(1) ✔</td>
    </tr>
    <tr>
      <td><strong>맨뒤 삭제</strong></td>
      <td>-</td>
      <td>O(1) ✔</td>
      <td>O(1) ✔</td>
    </tr>
    <tr>
      <td><strong>중간 삭제</strong></td>
      <td>-</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td><strong>메모리 효율</strong></td>
      <td>높음 ✔</td>
      <td>중간</td>
      <td>낮음 (포인터) ✘</td>
    </tr>
    <tr>
      <td><strong>캐시 효율</strong></td>
      <td>높음 ✔</td>
      <td>높음 ✔</td>
      <td>낮음 ✘</td>
    </tr>
    <tr>
      <td><strong>Null 허용</strong></td>
      <td>타입에 따라</td>
      <td>✔</td>
      <td>✔</td>
    </tr>
    <tr>
      <td><strong>초기 용량</strong></td>
      <td>필수</td>
      <td>선택 (기본 10)</td>
      <td>불필요</td>
    </tr>
    <tr>
      <td><strong>Thread-Safe</strong></td>
      <td>-</td>
      <td>✘</td>
      <td>✘</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="1️⃣-array-배열">1️⃣ Array (배열)</h2>

<h3 id="특징-3">특징</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 고정 크기</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>

<span class="c1">// 크기 변경 불가</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>  <span class="c1">// ✘ ArrayIndexOutOfBoundsException</span>
</code></pre></div></div>

<h3 id="메모리-구조">메모리 구조</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] arr = {10, 20, 30, 40, 50};

메모리:
주소   | 1000 | 1004 | 1008 | 1012 | 1016 |
-------|------|------|------|------|------|
인덱스 |  0   |  1   |  2   |  3   |  4   |
값     |  10  |  20  |  30  |  40  |  50  |

연속된 메모리 공간 ✔
</code></pre></div></div>

<h3 id="장단점-3">장단점</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
✔ 인덱스로 O(1) 접근
✔ 메모리 효율적 (오버헤드 없음)
✔ 캐시 친화적
✔ 원시 타입 저장 가능
✔ 성능 최적화

단점:
✘ 크기 고정 (변경 불가)
✘ 삽입/삭제 시 수동 관리 필요
✘ 크기 초과 시 새 배열 생성 필요
</code></pre></div></div>

<h3 id="사용-사례-2">사용 사례</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 크기가 고정된 경우
✔ 메모리가 제한적일 때
✔ 고성능이 중요한 경우
✔ 원시 타입 저장 (int, double 등)

예시:
- 고정된 학생 수 (30명)
- 요일 배열 (7개)
- RGB 색상 (3개 값)
</code></pre></div></div>

<hr />

<h2 id="2️⃣-arraylist">2️⃣ ArrayList</h2>

<h3 id="특징-4">특징</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동적 크기</span>
<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 초기 용량 지정 가능</span>
<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">100</span><span class="o">);</span>

<span class="c1">// 크기 자동 조절</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>  <span class="c1">// size: 1</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>  <span class="c1">// size: 2</span>
<span class="c1">// 계속 추가 가능... ✔</span>
</code></pre></div></div>

<h3 id="내부-구조">내부 구조</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">elementData</span><span class="o">;</span>  <span class="c1">// 내부 배열</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>              <span class="c1">// 현재 원소 수</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_CAPACITY</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="동적-확장-resizing">동적 확장 (Resizing)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: 용량 10
[0][1][2][3][4][5][6][7][8][9]

10개 채움:
[10][20][30][40][50][60][70][80][90][100]

11번째 추가 시:
1. 새 배열 생성 (용량 15 = 10 * 1.5)
2. 기존 원소 복사
3. 새 원소 추가

[10][20][30][40][50][60][70][80][90][100][110][_][_][_][_]

시간복잡도:
- 일반 add: O(1)
- resizing 발생: O(N)
- 분할 상환: O(1) ✔
</code></pre></div></div>

<h3 id="주요-메서드">주요 메서드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 삽입</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>           <span class="c1">// 맨 뒤: O(1)</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>         <span class="c1">// 맨 앞: O(N)</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">15</span><span class="o">);</span>        <span class="c1">// 중간: O(N)</span>

<span class="c1">// 접근</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>  <span class="c1">// O(1) ✔</span>

<span class="c1">// 수정</span>
<span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">20</span><span class="o">);</span>        <span class="c1">// O(1)</span>

<span class="c1">// 삭제</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>         <span class="c1">// 맨 앞: O(N)</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>  <span class="c1">// 맨 뒤: O(1)</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>  <span class="c1">// 값으로: O(N)</span>

<span class="c1">// 검색</span>
<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>  <span class="c1">// O(N)</span>
<span class="kt">boolean</span> <span class="n">exists</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>  <span class="c1">// O(N)</span>

<span class="c1">// 크기</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>

<span class="c1">// 용량</span>
<span class="n">list</span><span class="o">.</span><span class="na">ensureCapacity</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>  <span class="c1">// 미리 용량 확보</span>
<span class="n">list</span><span class="o">.</span><span class="na">trimToSize</span><span class="o">();</span>         <span class="c1">// 불필요한 용량 제거</span>
</code></pre></div></div>

<h3 id="중간-삽입삭제-과정">중간 삽입/삭제 과정</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 중간 삽입</span>
<span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">]</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">25</span><span class="o">);</span>

<span class="mi">1</span><span class="o">.</span> <span class="n">인덱스</span> <span class="mi">2</span><span class="n">부터</span> <span class="n">뒤로</span> <span class="nl">이동:</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="n">_</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">]</span>

<span class="mi">2</span><span class="o">.</span> <span class="n">인덱스</span> <span class="mi">2</span><span class="n">에</span> <span class="nl">삽입:</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">25</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">]</span>

<span class="c1">// 중간 삭제</span>
<span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">]</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="mi">1</span><span class="o">.</span> <span class="n">인덱스</span> <span class="mi">2</span> <span class="n">삭제</span>
<span class="mi">2</span><span class="o">.</span> <span class="n">뒤의</span> <span class="n">원소들</span> <span class="n">앞으로</span> <span class="nl">이동:</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="n">_</span><span class="o">]</span>

<span class="n">이동</span> <span class="nl">횟수:</span> <span class="no">N</span> <span class="o">-</span> <span class="n">index</span>
<span class="nl">시간복잡도:</span> <span class="no">O</span><span class="o">(</span><span class="no">N</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="장단점-4">장단점</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
✔ 동적 크기 조절
✔ 인덱스로 O(1) 접근
✔ 사용하기 편리 (API 풍부)
✔ 순차 접근 시 빠름 (캐시 효율)
✔ 메모리 연속 배치

단점:
✘ 중간 삽입/삭제 느림 O(N)
✘ Resizing 오버헤드
✘ 초기 용량 낭비 가능
✘ 원시 타입 저장 시 Boxing 필요
</code></pre></div></div>

<h3 id="사용-사례-3">사용 사례</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 인덱스 접근이 빈번할 때
✔ 순차 접근이 많을 때
✔ 맨 뒤 삽입/삭제가 주된 작업
✔ 크기 예측 가능할 때

예시:
- 검색 결과 리스트
- 로그 저장
- 데이터 수집 후 분석
</code></pre></div></div>

<hr />

<h2 id="3️⃣-linkedlist">3️⃣ LinkedList</h2>

<h3 id="특징-5">특징</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이중 연결 리스트</span>
<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 양방향 접근 가능</span>
<span class="n">list</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>   <span class="c1">// 맨 앞 추가</span>
<span class="n">list</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>    <span class="c1">// 맨 뒤 추가</span>
<span class="n">list</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>     <span class="c1">// 맨 앞 조회</span>
<span class="n">list</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>      <span class="c1">// 맨 뒤 조회</span>
</code></pre></div></div>

<h3 id="내부-구조-1">내부 구조</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="no">E</span> <span class="n">item</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>    <span class="c1">// 다음 노드</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>    <span class="c1">// 이전 노드</span>
        
        <span class="nc">Node</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>  <span class="c1">// 첫 노드</span>
    <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">last</span><span class="o">;</span>   <span class="c1">// 마지막 노드</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="메모리-구조-1">메모리 구조</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LinkedList: [10, 20, 30, 40]

NULL ← [10|●] ⇄ [20|●] ⇄ [30|●] ⇄ [40|●] → NULL
       ↑                              ↑
     first                          last

각 노드:
- item: 데이터 (8바이트, 참조)
- next: 다음 노드 포인터 (8바이트)
- prev: 이전 노드 포인터 (8바이트)

총 24바이트/노드 (ArrayList는 8바이트)
</code></pre></div></div>

<h3 id="주요-메서드-1">주요 메서드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 삽입</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>           <span class="c1">// 맨 뒤: O(1)</span>
<span class="n">list</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>       <span class="c1">// 맨 앞: O(1) ✔</span>
<span class="n">list</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="mi">15</span><span class="o">);</span>       <span class="c1">// 맨 뒤: O(1)</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">);</span>        <span class="c1">// 중간: O(N)</span>

<span class="c1">// 접근</span>
<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>   <span class="c1">// O(1)</span>
<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>     <span class="c1">// O(1)</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>       <span class="c1">// O(N) ✘</span>

<span class="c1">// 삭제</span>
<span class="n">list</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>     <span class="c1">// 맨 앞: O(1) ✔</span>
<span class="n">list</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>      <span class="c1">// 맨 뒤: O(1) ✔</span>
<span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>         <span class="c1">// 중간: O(N)</span>

<span class="c1">// 큐/스택 연산</span>
<span class="n">list</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>        <span class="c1">// 큐: enqueue</span>
<span class="n">list</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>           <span class="c1">// 큐: dequeue</span>
<span class="n">list</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>         <span class="c1">// 스택: push</span>
<span class="n">list</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>            <span class="c1">// 스택: pop</span>
</code></pre></div></div>

<h3 id="중간-접근-최적화">중간 접근 최적화</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// LinkedList의 get(index) 구현</span>
<span class="kd">public</span> <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 절반 기준으로 앞/뒤에서 탐색</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 앞에서부터 탐색</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 뒤에서부터 탐색</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">평균</span> <span class="n">이동</span> <span class="nl">횟수:</span> <span class="no">N</span><span class="o">/</span><span class="mi">4</span>
<span class="n">여전히</span> <span class="no">O</span><span class="o">(</span><span class="no">N</span><span class="o">)</span><span class="n">이지만</span> <span class="n">실제로는</span> <span class="mi">2</span><span class="n">배</span> <span class="n">빠름</span>
</code></pre></div></div>

<h3 id="장단점-5">장단점</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
✔ 맨 앞/뒤 삽입/삭제 O(1)
✔ 크기 제한 없음
✔ Resizing 오버헤드 없음
✔ 메모리 단편화 방지

단점:
✘ 인덱스 접근 O(N)
✘ 메모리 오버헤드 (포인터)
✘ 캐시 비효율적
✘ 순차 접근도 느림
</code></pre></div></div>

<h3 id="사용-사례-4">사용 사례</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✔ 맨 앞/뒤 삽입/삭제가 빈번할 때
✔ 큐(Queue) 구현
✔ 스택(Stack) 구현
✔ 덱(Deque) 구현
✔ 인덱스 접근이 없을 때

예시:
- 브라우저 방문 기록 (앞/뒤 이동)
- 음악 재생 목록
- Undo/Redo 기능
- 작업 큐
</code></pre></div></div>

<hr />

<h2 id="-상세-비교-1">🎯 상세 비교</h2>

<h3 id="1-메모리-사용량">1. 메모리 사용량</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1000개 Integer 저장 기준</span>

<span class="nc">Array</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]):</span>
<span class="mi">4</span><span class="n">바이트</span> <span class="err">×</span> <span class="mi">1000</span> <span class="o">=</span> <span class="mi">4</span><span class="no">KB</span> <span class="err">✔</span>

<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;:</span>
<span class="o">-</span> <span class="n">내부</span> <span class="nl">배열:</span> <span class="mi">8</span><span class="n">바이트</span> <span class="err">×</span> <span class="mi">1000</span> <span class="o">=</span> <span class="mi">8</span><span class="no">KB</span> <span class="o">(</span><span class="n">참조</span><span class="o">)</span>
<span class="o">-</span> <span class="nc">Integer</span> <span class="nl">객체:</span> <span class="mi">16</span><span class="n">바이트</span> <span class="err">×</span> <span class="mi">1000</span> <span class="o">=</span> <span class="mi">16</span><span class="no">KB</span>
<span class="o">-</span> <span class="nl">총:</span> <span class="mi">24</span><span class="no">KB</span>

<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;:</span>
<span class="o">-</span> <span class="nl">노드:</span> <span class="mi">24</span><span class="n">바이트</span> <span class="err">×</span> <span class="mi">1000</span> <span class="o">=</span> <span class="mi">24</span><span class="no">KB</span>
<span class="o">-</span> <span class="nc">Integer</span> <span class="nl">객체:</span> <span class="mi">16</span><span class="n">바이트</span> <span class="err">×</span> <span class="mi">1000</span> <span class="o">=</span> <span class="mi">16</span><span class="no">KB</span>
<span class="o">-</span> <span class="nl">총:</span> <span class="mi">40</span><span class="no">KB</span> <span class="err">✘</span>

<span class="nc">LinkedList가</span> <span class="nc">ArrayList보다</span> <span class="mf">1.7</span><span class="n">배</span> <span class="n">많은</span> <span class="n">메모리</span> <span class="n">사용</span>
</code></pre></div></div>

<h3 id="2-성능-비교-실측">2. 성능 비교 (실측)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10,000개 원소 기준:

1. 순차 접근 (0부터 9999까지):
   Array:      0.1ms ✔
   ArrayList:  0.2ms
   LinkedList: 1500ms ✘ (15,000배 느림!)

2. 랜덤 접근 (무작위 인덱스):
   Array:      0.5ms ✔
   ArrayList:  0.6ms
   LinkedList: 750ms ✘

3. 맨 앞 삽입 1000번:
   ArrayList:  150ms (매번 이동)
   LinkedList: 0.1ms ✔

4. 맨 뒤 삽입 10,000번:
   ArrayList:  1ms ✔
   LinkedList: 2ms

5. 중간 삽입 1000번:
   ArrayList:  80ms
   LinkedList: 90ms
   (거의 비슷, 둘 다 O(N))
</code></pre></div></div>

<h3 id="3-반복-성능">3. 반복 성능</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="o">...</span> <span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mo">000</span><span class="n">개</span><span class="o">)</span>

<span class="c1">// 1. for-each (Iterator 사용)</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">value</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
<span class="c1">// ArrayList: 1ms ✔</span>
<span class="c1">// LinkedList: 2ms (노드 탐색)</span>

<span class="c1">// 2. 인덱스 접근</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// ArrayList: 1ms ✔</span>
<span class="c1">// LinkedList: 1500ms ✘ (절대 사용하지 말 것!)</span>

<span class="c1">// 3. Iterator 직접 사용</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">// ArrayList: 1ms ✔</span>
<span class="c1">// LinkedList: 2ms</span>
</code></pre></div></div>

<p><strong>결론: LinkedList는 반드시 Iterator나 for-each 사용!</strong></p>

<hr />

<h2 id="-면접-답변-예시-3">💬 면접 답변 예시</h2>

<h3 id="짧은-답변-3">짧은 답변</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array:
- 고정 크기, 연속 메모리
- 인덱스 접근 O(1)
- 원시 타입 저장 가능

ArrayList:
- 동적 배열 (내부는 배열)
- 인덱스 접근 O(1)
- 맨 뒤 삽입/삭제 빠름

LinkedList:
- 이중 연결 리스트
- 맨 앞/뒤 삽입/삭제 O(1)
- 인덱스 접근 O(N)

선택 기준:
- 인덱스 접근 많음 → ArrayList
- 맨 앞 삽입/삭제 많음 → LinkedList
- 고정 크기 + 원시 타입 → Array
</code></pre></div></div>

<h3 id="상세-답변-3">상세 답변</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Array (배열):
   
   특징:
   - 고정 크기, 연속된 메모리 공간
   - 컴파일 타임에 크기 결정
   - 원시 타입(int, double) 직접 저장 가능
   
   성능:
   - 접근: O(1) ✔
   - 메모리: 가장 효율적 ✔
   - 캐시: 가장 효율적 ✔
   
   사용:
   - 크기 고정 (요일, RGB 값 등)
   - 고성능 필요 시
   - 메모리 제한적일 때

2. ArrayList:
   
   특징:
   - 내부적으로 배열 사용
   - 동적 크기 조절 (자동 확장)
   - 기본 용량 10, 1.5배씩 증가
   
   성능:
   - 접근: O(1) ✔
   - 맨 뒤 삽입: O(1) 분할상환
   - 중간 삽입/삭제: O(N) (원소 이동)
   - 메모리: 연속 배치로 캐시 효율 높음
   
   내부 동작:
   - 용량 초과 시 새 배열 생성 및 복사
   - 메모리 재할당 오버헤드
   
   사용:
   - 인덱스 접근이 주된 작업
   - 맨 뒤 삽입이 대부분
   - 크기 예측 가능 (초기 용량 지정)

3. LinkedList:
   
   특징:
   - 이중 연결 리스트 (prev, next 포인터)
   - 비연속적 메모리
   - first, last 포인터로 양 끝 관리
   
   성능:
   - 접근: O(N) ✘ (순차 탐색)
   - 맨 앞/뒤 삽입/삭제: O(1) ✔
   - 중간 삽입/삭제: O(N) (위치 찾기)
   - 메모리: 포인터 오버헤드 (노드당 24바이트)
   
   주의사항:
   - get(index) 절대 사용 금지!
   - Iterator나 for-each만 사용
   
   사용:
   - 큐/스택/덱 구현
   - 맨 앞 삽입/삭제가 빈번
   - 인덱스 접근이 없는 경우

성능 비교 (10,000개 기준):
                  | ArrayList | LinkedList
------------------|-----------|------------
순차 접근         | 0.2ms ✔  | 1500ms ✘
맨 앞 삽입 1000번 | 150ms     | 0.1ms ✔
메모리 (Integer)  | 24KB      | 40KB

선택 기준:
- 읽기가 99% → ArrayList
- 맨 앞 작업이 많음 → LinkedList
- 원시 타입 + 고정 크기 → Array
- 실무에서는 대부분 ArrayList 사용
</code></pre></div></div>

<hr />

<h2 id="-추가-팁">🎓 추가 팁</h2>

<h3 id="arraylist-최적화">ArrayList 최적화</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✘ 비효율적</span>
<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>  <span class="c1">// 여러 번 resizing</span>
<span class="o">}</span>

<span class="c1">// ✔ 효율적</span>
<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">10000</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>  <span class="c1">// resizing 없음</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="linkedlist-주의사항">LinkedList 주의사항</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="o">...;</span>

<span class="c1">// ✘ 절대 금지! O(N²)</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>  <span class="c1">// 매번 O(N)</span>
<span class="o">}</span>

<span class="c1">// ✔ 올바른 방법 O(N)</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">value</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>

<span class="c1">// ✔ Iterator 사용</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="thread-safe-버전">Thread-Safe 버전</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ArrayList</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">syncList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>

<span class="c1">// CopyOnWriteArrayList (읽기가 많을 때)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cowList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;&gt;();</span>

<span class="c1">// LinkedList</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">syncLinked</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;());</span>
</code></pre></div></div>

<hr />

<p><strong>핵심 정리:</strong></p>
<ol>
  <li><strong>인덱스 접근이 많으면 ArrayList</strong></li>
  <li><strong>맨 앞/뒤 작업이 많으면 LinkedList</strong></li>
  <li><strong>고정 크기 + 원시 타입이면 Array</strong></li>
  <li><strong>실무에서는 대부분 ArrayList 사용</strong></li>
  <li><strong>LinkedList는 get(index) 절대 사용 금지!</strong></li>
</ol>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 yunYoung e. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
