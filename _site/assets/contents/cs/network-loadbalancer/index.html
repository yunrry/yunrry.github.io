<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>네트워크 완벽 정리 - 로드밸런서 &amp; IP 주소 - AD윤영스윗투웬티HD</title>
<meta name="description" content="2026년 목표: 개발로 월급받기추가 정보 없음">


  <meta name="author" content="yunYoung e">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="AD윤영스윗투웬티HD">
<meta property="og:title" content="네트워크 완벽 정리 - 로드밸런서 &amp; IP 주소">
<meta property="og:url" content="http://localhost:4000/assets/contents/cs/network-loadbalancer/">


  <meta property="og:description" content="2026년 목표: 개발로 월급받기추가 정보 없음">












<link rel="canonical" href="http://localhost:4000/assets/contents/cs/network-loadbalancer/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "yunYoung e",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="AD윤영스윗투웬티HD Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>


  
    <script src="/assets/js/custom.js"></script>
  


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--default">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          AD윤영스윗투웬티HD
          <span class="site-subtitle">뇌정리노트</span>
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      <h1 id="네트워크-완벽-정리---로드밸런서--ip-주소">네트워크 완벽 정리 - 로드밸런서 &amp; IP 주소</h1>

<hr />

<h1 id="9-로드밸런서-load-balancer">9. 로드밸런서 (Load Balancer)</h1>

<h2 id="-개념">📌 개념</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>여러 서버에 트래픽을 분산시키는 장치/소프트웨어
- 서버 부하 분산
- 고가용성 (High Availability)
- 확장성 (Scalability)
</code></pre></div></div>

<h3 id="기본-구조">기본 구조</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         Client
            |
            | 요청
            ↓
      ┌──────────┐
      │ Load     │
      │ Balancer │
      └──────────┘
       /    |    \
      /     |     \
     ↓      ↓      ↓
[Server1][Server2][Server3]

트래픽을 여러 서버에 분산 ✅
</code></pre></div></div>

<hr />

<h2 id="-로드밸런서의-역할">🎯 로드밸런서의 역할</h2>

<h3 id="1-부하-분산">1. 부하 분산</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>문제:
- 단일 서버에 모든 요청 집중
- 서버 과부하, 응답 지연

해결:
Client1 → Server1
Client2 → Server2
Client3 → Server3
Client4 → Server1
...

각 서버가 균등하게 처리 ✅
</code></pre></div></div>

<h3 id="2-고가용성-ha">2. 고가용성 (HA)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>문제:
- 서버 1대 장애 → 서비스 중단

해결:
Server1 장애 발생
    ↓
로드밸런서가 감지
    ↓
Server1 제외
    ↓
Server2, Server3로만 트래픽 전송

서비스 지속 ✅
</code></pre></div></div>

<h3 id="3-health-check-헬스-체크">3. Health Check (헬스 체크)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>주기적으로 서버 상태 확인

방법:
- HTTP 요청: GET /health
- TCP 연결 확인
- Ping

응답:
- 200 OK → 정상
- Timeout/Error → 비정상

비정상 서버는 자동 제외 ✅
</code></pre></div></div>

<h3 id="4-확장성">4. 확장성</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>수평 확장 (Scale-Out):

트래픽 증가
    ↓
서버 추가 (3대 → 5대)
    ↓
로드밸런서가 자동으로 분산
    ↓
처리 용량 증가 ✅

서버 추가/제거가 쉬움
</code></pre></div></div>

<hr />

<h2 id="-로드밸런싱-알고리즘">🔄 로드밸런싱 알고리즘</h2>

<h3 id="1-round-robin-라운드-로빈">1. Round Robin (라운드 로빈)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>순서대로 분배

동작:
요청1 → Server1
요청2 → Server2
요청3 → Server3
요청4 → Server1 (다시 처음부터)
요청5 → Server2
...

장점:
✅ 구현 간단
✅ 균등 분배

단점:
❌ 서버 성능 차이 고려 안 함
❌ 세션 유지 어려움

사용:
- 서버 성능이 동일할 때
- Stateless 애플리케이션
</code></pre></div></div>

<h3 id="2-weighted-round-robin-가중-라운드-로빈">2. Weighted Round Robin (가중 라운드 로빈)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>서버 성능에 따라 가중치 부여

설정:
Server1: 가중치 3
Server2: 가중치 2
Server3: 가중치 1

동작:
Server1에 3번 할당
Server2에 2번 할당
Server3에 1번 할당
(총 6번 중)

예:
요청1 → Server1
요청2 → Server1
요청3 → Server1
요청4 → Server2
요청5 → Server2
요청6 → Server3

장점:
✅ 서버 성능 차이 반영

사용:
- 서버 스펙이 다를 때
</code></pre></div></div>

<h3 id="3-least-connections-최소-연결">3. Least Connections (최소 연결)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>현재 연결 수가 가장 적은 서버에 할당

상태:
Server1: 10개 연결
Server2: 5개 연결  ← 선택
Server3: 8개 연결

새 요청 → Server2 (연결 수 가장 적음)

장점:
✅ 실시간 부하 고려
✅ 긴 요청 처리에 유리

단점:
❌ 연결 수 추적 필요
❌ 약간 복잡

사용:
- 요청 처리 시간이 다양할 때
- 긴 커넥션 유지 (WebSocket 등)
</code></pre></div></div>

<h3 id="4-weighted-least-connections">4. Weighted Least Connections</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최소 연결 + 가중치

상태:
Server1 (가중치 2): 10개 연결 → 비율 10/2 = 5
Server2 (가중치 1): 5개 연결 → 비율 5/1 = 5
Server3 (가중치 3): 12개 연결 → 비율 12/3 = 4 ← 선택

새 요청 → Server3 (비율이 가장 낮음)

장점:
✅ 성능 차이 + 현재 부하 모두 고려
</code></pre></div></div>

<h3 id="5-ip-hash">5. IP Hash</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>클라이언트 IP 주소를 해시하여 서버 선택

동작:
hash(Client IP) % 서버 수 = 서버 인덱스

예:
Client A (IP: 192.168.1.10)
hash(192.168.1.10) % 3 = 1
→ 항상 Server1

Client B (IP: 192.168.1.20)
hash(192.168.1.20) % 3 = 2
→ 항상 Server2

장점:
✅ 같은 클라이언트는 같은 서버
✅ 세션 유지 쉬움

단점:
❌ 서버 추가/제거 시 재분배
❌ 특정 서버에 부하 집중 가능

사용:
- 세션 기반 애플리케이션
- Stateful 서비스
</code></pre></div></div>

<h3 id="6-least-response-time-최소-응답-시간">6. Least Response Time (최소 응답 시간)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>응답 시간이 가장 빠른 서버 선택

상태:
Server1: 평균 응답 100ms
Server2: 평균 응답 50ms  ← 선택
Server3: 평균 응답 80ms

장점:
✅ 최적의 성능
✅ 사용자 경험 향상

단점:
❌ 응답 시간 측정 필요
❌ 구현 복잡
</code></pre></div></div>

<hr />

<h2 id="️-로드밸런서-유형">🏗️ 로드밸런서 유형</h2>

<h3 id="l4-로드밸런서-transport-layer">L4 로드밸런서 (Transport Layer)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OSI 4계층 (전송 계층)에서 동작
- IP, Port 기반 분산
- TCP/UDP 레벨

동작:
Client → LB (IP:Port 확인)
         ↓
      Server 선택 (IP, Port 기반)

특징:
✅ 빠른 속도
✅ 간단한 구조
❌ 내용 기반 라우팅 불가

정보:
- Source IP
- Destination IP
- Source Port
- Destination Port
- Protocol (TCP/UDP)

사용:
- 단순 부하 분산
- 고성능 필요
</code></pre></div></div>

<h3 id="l7-로드밸런서-application-layer">L7 로드밸런서 (Application Layer)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OSI 7계층 (응용 계층)에서 동작
- HTTP 헤더, URL, 쿠키 등 기반 분산
- 콘텐츠 기반 라우팅

동작:
Client → LB (HTTP 요청 분석)
         ↓
      URL, Header 확인
         ↓
      Server 선택 (콘텐츠 기반)

특징:
✅ 유연한 라우팅
✅ SSL 종료 가능
✅ 캐싱, 압축 등 부가 기능
❌ 느린 속도 (패킷 분석)

정보:
- HTTP 메서드 (GET, POST)
- URL 경로
- HTTP 헤더
- 쿠키
- Body 내용

사용:
- 마이크로서비스
- 복잡한 라우팅 규칙
</code></pre></div></div>

<h3 id="l4-vs-l7-비교">L4 vs L7 비교</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>예시:

L4:
모든 /api/* 요청 → Server1, 2, 3 (Round Robin)
간단하지만 유연성 낮음

L7:
/api/users/*    → User Service (Server1, 2)
/api/orders/*   → Order Service (Server3, 4)
/api/products/* → Product Service (Server5, 6)

유연하지만 약간 느림
</code></pre></div></div>

<hr />

<h2 id="-로드밸런서-구현">💻 로드밸런서 구현</h2>

<h3 id="소프트웨어-로드밸런서">소프트웨어 로드밸런서</h3>

<h4 id="1-nginx">1. Nginx</h4>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># nginx.conf</span>

<span class="k">http</span> <span class="p">{</span>
    <span class="kn">upstream</span> <span class="s">backend</span> <span class="p">{</span>
        <span class="c1"># 로드밸런싱 알고리즘</span>
        <span class="kn">least_conn</span><span class="p">;</span>  <span class="c1"># 최소 연결</span>
        
        <span class="c1"># 서버 목록 (가중치 포함)</span>
        <span class="kn">server</span> <span class="nf">192.168.1.10</span><span class="p">:</span><span class="mi">8080</span> <span class="s">weight=3</span><span class="p">;</span>
        <span class="kn">server</span> <span class="nf">192.168.1.11</span><span class="p">:</span><span class="mi">8080</span> <span class="s">weight=2</span><span class="p">;</span>
        <span class="kn">server</span> <span class="nf">192.168.1.12</span><span class="p">:</span><span class="mi">8080</span> <span class="s">weight=1</span><span class="p">;</span>
        
        <span class="c1"># 헬스 체크</span>
        <span class="kn">server</span> <span class="nf">192.168.1.13</span><span class="p">:</span><span class="mi">8080</span> <span class="s">backup</span><span class="p">;</span>  <span class="c1"># 백업 서버</span>
    <span class="p">}</span>
    
    <span class="kn">server</span> <span class="p">{</span>
        <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
        
        <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
            <span class="kn">proxy_pass</span> <span class="s">http://backend</span><span class="p">;</span>
            <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
            <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="2-haproxy">2. HAProxy</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># haproxy.cfg

frontend http_front
    bind *:80
    default_backend http_back

backend http_back
    balance roundrobin
    
    # 헬스 체크
    option httpchk GET /health
    
    # 서버 목록
    server server1 192.168.1.10:8080 check
    server server2 192.168.1.11:8080 check
    server server3 192.168.1.12:8080 check
</code></pre></div></div>

<h3 id="하드웨어-로드밸서">하드웨어 로드밸서</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>상용 제품:
- F5 Networks
- Citrix NetScaler
- A10 Networks

특징:
✅ 고성능 (전용 하드웨어)
✅ 안정성
❌ 고가
❌ 유연성 낮음
</code></pre></div></div>

<h3 id="클라우드-로드밸런서">클라우드 로드밸런서</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AWS:
- ELB (Elastic Load Balancer)
  - ALB (Application Load Balancer) - L7
  - NLB (Network Load Balancer) - L4
  - CLB (Classic Load Balancer) - L4/L7

GCP:
- Cloud Load Balancing
  - HTTP(S) Load Balancing - L7
  - TCP/UDP Load Balancing - L4

Azure:
- Azure Load Balancer - L4
- Application Gateway - L7

특징:
✅ 관리 불필요 (Managed)
✅ 자동 확장
✅ 고가용성
✅ 사용한 만큼 과금
</code></pre></div></div>

<hr />

<h2 id="-세션-관리-session-persistence">🔐 세션 관리 (Session Persistence)</h2>

<h3 id="문제">문제</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stateful 애플리케이션에서 세션 유지 필요

Client → Server1 (로그인, 세션 생성)
Client → Server2 (세션 없음!) ❌
</code></pre></div></div>

<h3 id="해결-방법">해결 방법</h3>

<h4 id="1-sticky-session-session-affinity">1. Sticky Session (Session Affinity)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>같은 클라이언트는 항상 같은 서버

구현:
- 쿠키 기반
- IP Hash

예:
Client A → Server1 (첫 요청)
          → Server1 (이후 모든 요청)

장점:
✅ 구현 간단
✅ 세션 공유 불필요

단점:
❌ 부하 불균형 가능
❌ 서버 장애 시 세션 손실
</code></pre></div></div>

<h4 id="2-session-clustering">2. Session Clustering</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>모든 서버가 세션 공유

[Server1] ─┐
[Server2] ─┼─ 세션 복제
[Server3] ─┘

장점:
✅ 어느 서버든 가능
✅ 서버 장애에도 세션 유지

단점:
❌ 네트워크 오버헤드
❌ 서버 수 증가 시 부담
</code></pre></div></div>

<h4 id="3-session-storage-추천-">3. Session Storage (추천) ✅</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>중앙 저장소에 세션 저장

[Server1] ─┐
[Server2] ─┼─ Redis/Memcached
[Server3] ─┘

동작:
1. Server1에서 세션 생성 → Redis 저장
2. Server2에서 세션 조회 → Redis에서 가져옴

장점:
✅ 완벽한 부하 분산
✅ 서버 추가/제거 자유
✅ 서버 장애에도 세션 유지

단점:
❌ Redis 등 추가 인프라
❌ 약간의 지연

사용:
- 대부분의 현대적 애플리케이션
</code></pre></div></div>

<hr />

<h2 id="-로드밸런서-모니터링">📊 로드밸런서 모니터링</h2>

<h3 id="health-check-설정">Health Check 설정</h3>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Nginx</span>
<span class="k">upstream</span> <span class="s">backend</span> <span class="p">{</span>
    <span class="kn">server</span> <span class="nf">192.168.1.10</span><span class="p">:</span><span class="mi">8080</span><span class="p">;</span>
    <span class="kn">server</span> <span class="nf">192.168.1.11</span><span class="p">:</span><span class="mi">8080</span><span class="p">;</span>
    
    <span class="c1"># 헬스 체크 설정</span>
    <span class="kn">check</span> <span class="s">interval=3000</span> <span class="s">rise=2</span> <span class="s">fall=3</span> <span class="s">timeout=1000</span><span class="p">;</span>
    <span class="c1"># interval: 3초마다 체크</span>
    <span class="c1"># rise: 2번 성공 시 정상</span>
    <span class="c1"># fall: 3번 실패 시 비정상</span>
    <span class="c1"># timeout: 1초 내 응답 없으면 실패</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="메트릭">메트릭</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>모니터링 지표:

1. 서버 상태:
   - Active Servers
   - Failed Servers
   - Health Check Status

2. 트래픽:
   - Requests per Second
   - Bandwidth
   - Active Connections

3. 응답 시간:
   - Average Response Time
   - P95, P99 Latency

4. 오류율:
   - 4xx Errors
   - 5xx Errors
   - Timeout Rate

5. 분산 비율:
   - Requests per Server
   - Load Distribution
</code></pre></div></div>

<hr />

<h2 id="-면접-답변-예시">💬 면접 답변 예시</h2>

<h3 id="짧은-답변">짧은 답변</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>로드밸런서는 여러 서버에 트래픽을 
분산시키는 장치입니다.

역할:
- 부하 분산
- 고가용성 (서버 장애 대응)
- Health Check

알고리즘:
- Round Robin: 순서대로
- Least Connections: 연결 적은 곳
- IP Hash: 같은 클라이언트 → 같은 서버

유형:
- L4: IP/Port 기반 (빠름)
- L7: HTTP 내용 기반 (유연)
</code></pre></div></div>

<h3 id="상세-답변">상세 답변</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>로드밸런서 (Load Balancer):

정의:
여러 서버에 네트워크 트래픽을 분산시켜
성능과 가용성을 향상시키는 장치/소프트웨어

주요 역할:

1. 부하 분산:
   - 트래픽을 여러 서버에 균등 분배
   - 서버 과부하 방지
   - 응답 시간 개선

2. 고가용성 (HA):
   - Health Check로 서버 상태 감시
   - 장애 서버 자동 제외
   - 무중단 서비스

3. 확장성:
   - 서버 추가/제거 용이
   - 수평 확장 (Scale-Out)
   - 트래픽 증가에 대응

로드밸런싱 알고리즘:

1. Round Robin:
   - 순서대로 분배
   - 간단, 균등 분배
   
2. Weighted Round Robin:
   - 서버 성능 반영
   - 가중치 부여
   
3. Least Connections:
   - 연결 수 가장 적은 서버
   - 실시간 부하 고려
   
4. IP Hash:
   - 클라이언트 IP 기반
   - 세션 유지

5. Least Response Time:
   - 응답 시간 가장 빠른 서버
   - 최적 성능

유형:

L4 (Transport Layer):
- IP, Port 기반
- TCP/UDP 레벨
- 빠른 속도
- 간단한 라우팅

L7 (Application Layer):
- HTTP 헤더, URL 기반
- 콘텐츠 기반 라우팅
- SSL 종료 가능
- 유연하지만 느림

세션 관리:

1. Sticky Session:
   - 같은 클라이언트 → 같은 서버
   - 구현 간단
   - 부하 불균형 가능

2. Session Storage (추천):
   - Redis 등 중앙 저장소
   - 완벽한 부하 분산
   - 고가용성

구현:

소프트웨어:
- Nginx (오픈소스)
- HAProxy (오픈소스)
- Apache mod_proxy

클라우드:
- AWS ELB (ALB, NLB)
- GCP Load Balancing
- Azure Load Balancer

Health Check:
- 주기적 상태 확인
- HTTP /health 엔드포인트
- 비정상 서버 자동 제외
- 복구 시 자동 포함

실무 활용:
- MSA (마이크로서비스)
- 대용량 트래픽 처리
- 무중단 배포 (Blue-Green)
- 지역별 라우팅 (Geo Load Balancing)
</code></pre></div></div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 yunYoung e. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
