<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>📌 배열 Array - Second Brain</title>
<meta name="description" content="2026년 목표: 개발로 월급받기추가 정보 없음">


  <meta name="author" content="yunYoung e">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Second Brain">
<meta property="og:title" content="📌 배열 Array">
<meta property="og:url" content="http://localhost:4000/assets/contents/cs/array-linkedlist/">


  <meta property="og:description" content="2026년 목표: 개발로 월급받기추가 정보 없음">












<link rel="canonical" href="http://localhost:4000/assets/contents/cs/array-linkedlist/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "yunYoung e",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Second Brain Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>


  
    <script src="/assets/js/custom.js"></script>
  


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--default">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Second Brain
          <span class="site-subtitle">뇌정리노트</span>
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
<h1 id="-배열-array">📌 배열 Array</h1>

<p><strong>같은 타입의 데이터를 연속된 메모리 공간에 저장하는 자료구조</strong></p>
<ul>
  <li>인덱스로 빠른 접근 가능</li>
  <li>고정된 크기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>배열: int arr[5] = {10, 20, 30, 40, 50};

메모리:
주소    | 1000 | 1004 | 1008 | 1012 | 1016 |
--------|------|------|------|------|------|
인덱스  |  0   |  1   |  2   |  3   |  4   |
값      |  10  |  20  |  30  |  40  |  50  |

연속된 메모리 공간에 저장 ✅
</code></pre></div></div>

<hr />

<h2 id="-배열의-기본-연산">🔧 배열의 기본 연산</h2>

<h3 id="1-선언-및-초기화">1. 선언 및 초기화</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 선언</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="c1">// 선언과 동시에 초기화</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>

<span class="c1">// 부분 초기화 (나머지는 0)</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>  <span class="c1">// {10, 20, 0, 0, 0}</span>

<span class="c1">// 모두 0으로 초기화</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">// 크기 생략 (컴파일러가 자동 계산)</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>  <span class="c1">// 크기: 3</span>
</code></pre></div></div>

<h3 id="2-접근-access">2. 접근 (Access)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>

<span class="c1">// 읽기</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// 30</span>

<span class="c1">// 쓰기</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// {10, 20, 100, 40, 50}</span>

<span class="c1">// 시간복잡도: O(1) ✅ (인덱스로 직접 접근)</span>
</code></pre></div></div>

<p><strong>인덱스 계산 공식:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>주소 = 시작주소 + (인덱스 × 데이터크기)

arr[2]의 주소 = 1000 + (2 × 4) = 1008
(int는 4바이트)
</code></pre></div></div>

<h3 id="3-탐색-search">3. 탐색 (Search)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 선형 탐색 (Linear Search)</span>
<span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 찾은 인덱스 반환</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// 못 찾음</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arr[] = {10, 20, 30, 40, 50}
key = 30 찾기

비교 1: arr[0] = 10 ≠ 30
비교 2: arr[1] = 20 ≠ 30
비교 3: arr[2] = 30 = 30 ✅ 찾음!

최악의 경우: N번 비교 (맨 끝 또는 없음)
</code></pre></div></div>

<h3 id="4-삽입-insert">4. 삽입 (Insert)</h3>

<h4 id="맨-뒤-삽입-가장-빠름">맨 뒤 삽입 (가장 빠름)</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">// 맨 뒤에 60 삽입</span>
<span class="n">arr</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
<span class="n">size</span><span class="o">++</span><span class="p">;</span>

<span class="c1">// 결과: {10, 20, 30, 40, 50, 60}</span>
<span class="c1">// 시간복잡도: O(1) ✅</span>
</code></pre></div></div>

<h4 id="중간-삽입-느림">중간 삽입 (느림)</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertAt</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 뒤에서부터 한 칸씩 이동</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N) ❌</span>
</code></pre></div></div>

<p><strong>예시: 인덱스 2에 25 삽입</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: {10, 20, 30, 40, 50}
       0   1   2   3   4

1단계: 뒤에서부터 이동
{10, 20, 30, 40, 50, 50}  // 50 복사
{10, 20, 30, 40, 40, 50}  // 40 복사
{10, 20, 30, 30, 40, 50}  // 30 복사

2단계: 해당 위치에 삽입
{10, 20, 25, 30, 40, 50}
       0   1   2   3   4   5

이동 횟수: 3번 (size - index)
</code></pre></div></div>

<h3 id="5-삭제-delete">5. 삭제 (Delete)</h3>

<h4 id="맨-뒤-삭제-가장-빠름">맨 뒤 삭제 (가장 빠름)</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">// 맨 뒤 삭제</span>
<span class="n">size</span><span class="o">--</span><span class="p">;</span>

<span class="c1">// 결과: {10, 20, 30, 40} (50은 무시됨)</span>
<span class="c1">// 시간복잡도: O(1) ✅</span>
</code></pre></div></div>

<h4 id="중간-삭제-느림">중간 삭제 (느림)</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteAt</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 앞으로 한 칸씩 이동</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N) ❌</span>
</code></pre></div></div>

<p><strong>예시: 인덱스 2 삭제</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: {10, 20, 30, 40, 50}
       0   1   2   3   4

1단계: 앞으로 이동
{10, 20, 40, 40, 50}  // arr[2] = arr[3]
{10, 20, 40, 50, 50}  // arr[3] = arr[4]

2단계: 크기 감소
{10, 20, 40, 50}
 0   1   2   3

이동 횟수: 2번 (size - index - 1)
</code></pre></div></div>

<hr />

<h2 id="-배열의-장단점">📊 배열의 장단점</h2>

<h3 id="장점-">장점 ✅</h3>

<ol>
  <li><strong>빠른 접근 (Random Access)</strong>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// O(1) - 인덱스로 바로 접근</span>
</code></pre></div>    </div>
  </li>
  <li><strong>구현이 간단</strong>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>  <span class="c1">// 선언만 하면 됨</span>
</code></pre></div>    </div>
  </li>
  <li><strong>메모리 효율적</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터만 저장 (포인터 불필요)
int 배열: 4바이트 × N개 = 4N 바이트
</code></pre></div>    </div>
  </li>
  <li><strong>캐시 친화적 (Cache-Friendly)</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>연속된 메모리 → CPU 캐시 효율 높음
→ 성능 향상
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="단점-">단점 ❌</h3>

<ol>
  <li><strong>고정 크기</strong>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>  <span class="c1">// 크기 5로 고정</span>
<span class="c1">// 6개를 저장하고 싶으면? → 새 배열 생성 필요</span>
</code></pre></div>    </div>
  </li>
  <li><strong>삽입/삭제가 느림</strong>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 중간에 삽입/삭제 시 O(N)</span>
<span class="c1">// 모든 원소를 이동해야 함</span>
</code></pre></div>    </div>
  </li>
  <li><strong>메모리 낭비</strong>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>  <span class="c1">// 1000개 선언</span>
<span class="c1">// 실제 10개만 사용 → 990개 낭비</span>
</code></pre></div>    </div>
  </li>
  <li><strong>크기 변경 불가</strong>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="c1">// 런타임에 크기 변경 불가능</span>
<span class="c1">// (동적 배열 제외)</span>
</code></pre></div>    </div>
  </li>
</ol>

<hr />

<h2 id="-배열-활용-예제">💻 배열 활용 예제</h2>

<h3 id="1-최댓값최솟값-찾기">1. 최댓값/최솟값 찾기</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findMax</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">findMin</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<h3 id="2-배열-역순-정렬">2. 배열 역순 정렬</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 양 끝을 교환</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">];</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: {10, 20, 30, 40, 50}
       0   1   2   3   4

교환 1: arr[0] ↔ arr[4]
{50, 20, 30, 40, 10}

교환 2: arr[1] ↔ arr[3]
{50, 40, 30, 20, 10}

중간(arr[2])은 그대로
</code></pre></div></div>

<h3 id="3-중복-제거">3. 중복 제거</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">newSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 첫 원소는 항상 포함</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">isDuplicate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1">// 이전 원소들과 비교</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">newSize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">isDuplicate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 중복이 아니면 추가</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isDuplicate</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">newSize</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">newSize</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">newSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N²)</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: {10, 20, 10, 30, 20, 40}

처리:
10 → 추가 (첫 원소)
20 → 추가 (중복 아님)
10 → 제외 (중복)
30 → 추가 (중복 아님)
20 → 제외 (중복)
40 → 추가 (중복 아님)

결과: {10, 20, 30, 40}
</code></pre></div></div>

<hr />

<h2 id="-2차원-배열">🎯 2차원 배열</h2>

<h3 id="선언-및-초기화">선언 및 초기화</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 선언</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>  <span class="c1">// 3행 4열</span>

<span class="c1">// 초기화</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 일괄 초기화</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
</code></pre></div></div>

<h3 id="메모리-배치-행-우선-순서">메모리 배치 (행 우선 순서)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arr[3][4]:

논리적 구조:
     col0  col1  col2  col3
row0 [1]   [2]   [3]   [4]
row1 [5]   [6]   [7]   [8]
row2 [9]   [10]  [11]  [12]

실제 메모리 (연속 배치):
[1][2][3][4][5][6][7][8][9][10][11][12]
</code></pre></div></div>

<h3 id="2차원-배열-순회">2차원 배열 순회</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 행 우선 순회</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 출력:</span>
<span class="c1">// 1 2 3 4</span>
<span class="c1">// 5 6 7 8</span>
<span class="c1">// 9 10 11 12</span>
</code></pre></div></div>

<h3 id="주소-계산">주소 계산</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arr[i][j]의 주소 = 시작주소 + ((i × 열개수) + j) × 데이터크기

예: arr[1][2]의 주소
= 1000 + ((1 × 4) + 2) × 4
= 1000 + 6 × 4
= 1000 + 24
= 1024
</code></pre></div></div>

<hr />

<h1 id="-링크드-리스트-linkedlist">📌 링크드 리스트 LinkedList</h1>

<p><strong>노드들이 포인터로 연결된 자료구조</strong></p>
<ul>
  <li>동적 크기 조절 가능</li>
  <li>비연속적 메모리 사용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>노드 구조:
┌──────┬──────┐
│ data │ next │  → next: 다음 노드의 주소
└──────┴──────┘

링크드 리스트:
Head → [10|●] → [20|●] → [30|●] → [40|NULL]
       1000     2000     3000     4000

메모리는 비연속적! ✅
</code></pre></div></div>

<hr />

<h2 id="-링크드-리스트-구현">💻 링크드 리스트 구현</h2>

<h3 id="노드-구조체">노드 구조체</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>           <span class="c1">// 데이터</span>
    <span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>  <span class="c1">// 다음 노드 포인터</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="1-노드-생성">1. 노드 생성</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">createNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">newNode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Memory allocation failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-삽입-insert">2. 삽입 (Insert)</h3>

<h4 id="맨-앞-삽입-head에-삽입">맨 앞 삽입 (Head에 삽입)</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertFront</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>  <span class="c1">// 새 노드가 현재 head를 가리킴</span>
    <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>         <span class="c1">// head를 새 노드로 변경</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(1) ✅</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: Head → [20|●] → [30|NULL]

10 삽입:

1단계: 새 노드 생성
[10|NULL]

2단계: newNode-&gt;next = head
[10|●] → [20|●] → [30|NULL]

3단계: head = newNode
Head → [10|●] → [20|●] → [30|NULL]
</code></pre></div></div>

<h4 id="맨-뒤-삽입-tail에-삽입">맨 뒤 삽입 (Tail에 삽입)</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertBack</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    
    <span class="c1">// 리스트가 비어있으면</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 마지막 노드 찾기</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N) ❌ (마지막까지 순회)</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: Head → [10|●] → [20|NULL]

30 삽입:

1단계: 마지막 노드 찾기
Head → [10|●] → [20|NULL]
                  ↑
              current

2단계: current-&gt;next = newNode
Head → [10|●] → [20|●] → [30|NULL]
</code></pre></div></div>

<h4 id="중간-삽입-특정-위치">중간 삽입 (특정 위치)</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertAt</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    
    <span class="c1">// 맨 앞 삽입</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
        <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 이전 노드 찾기</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Invalid position</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>예시: 인덱스 2에 25 삽입</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: Head → [10|●] → [20|●] → [30|NULL]
              0         1         2

1단계: position-1 (1번) 노드 찾기
Head → [10|●] → [20|●] → [30|NULL]
                  ↑
              current

2단계: newNode-&gt;next = current-&gt;next
       current-&gt;next = newNode

결과: Head → [10|●] → [20|●] → [25|●] → [30|NULL]
              0         1         2         3
</code></pre></div></div>

<h3 id="3-삭제-delete">3. 삭제 (Delete)</h3>

<h4 id="맨-앞-삭제">맨 앞 삭제</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteFront</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"List is empty</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(1) ✅</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: Head → [10|●] → [20|●] → [30|NULL]

1단계: temp = head
temp → [10|●] → [20|●] → [30|NULL]
  ↓
Head

2단계: head = head-&gt;next
Head → [20|●] → [30|NULL]
temp → [10|●]

3단계: free(temp)
Head → [20|●] → [30|NULL]
</code></pre></div></div>

<h4 id="맨-뒤-삭제">맨 뒤 삭제</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteBack</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"List is empty</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 노드가 1개만 있을 때</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">);</span>
        <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 마지막 이전 노드 찾기</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">free</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N) ❌</span>
</code></pre></div></div>

<h4 id="특정-값-삭제">특정 값 삭제</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteValue</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 첫 노드가 삭제 대상</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
        <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 삭제할 노드의 이전 노드 찾기</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 못 찾음</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Value not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 삭제</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>예시: 20 삭제</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: Head → [10|●] → [20|●] → [30|NULL]

1단계: 20의 이전 노드(10) 찾기
Head → [10|●] → [20|●] → [30|NULL]
        ↑        ↑
    current    temp

2단계: current-&gt;next = temp-&gt;next
Head → [10|●] ─────┐
                    ↓
       [20|●]   [30|NULL]
        temp

3단계: free(temp)
Head → [10|●] → [30|NULL]
</code></pre></div></div>

<h3 id="4-탐색-search">4. 탐색 (Search)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">search</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">current</span><span class="p">;</span>  <span class="c1">// 찾음</span>
        <span class="p">}</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// 못 찾음</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<h3 id="5-출력-display">5. 출력 (Display)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"List: "</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d → "</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"NULL</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="6-전체-삭제-메모리-해제">6. 전체 삭제 (메모리 해제)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteAll</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="-링크드-리스트의-종류">🔗 링크드 리스트의 종류</h2>

<h3 id="1-단일-링크드-리스트-singly-linked-list">1. 단일 링크드 리스트 (Singly Linked List)</h3>

<p>위에서 설명한 기본 형태</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Head → [10|●] → [20|●] → [30|NULL]

특징:
- 한 방향으로만 이동 가능
- 이전 노드로 돌아갈 수 없음
</code></pre></div></div>

<h3 id="2-이중-링크드-리스트-doubly-linked-list">2. 이중 링크드 리스트 (Doubly Linked List)</h3>

<p>양방향 포인터</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">DNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">DNode</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>  <span class="c1">// 이전 노드</span>
    <span class="k">struct</span> <span class="n">DNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>  <span class="c1">// 다음 노드</span>
<span class="p">}</span> <span class="n">DNode</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NULL ← [10|●] ⇄ [20|●] ⇄ [30|●] → NULL
       prev  next
</code></pre></div></div>

<p><strong>장점:</strong></p>
<ul>
  <li>양방향 탐색 가능</li>
  <li>이전 노드 삭제 쉬움</li>
</ul>

<p><strong>단점:</strong></p>
<ul>
  <li>메모리 사용량 증가 (포인터 2개)</li>
  <li>구현 복잡</li>
</ul>

<h3 id="3-원형-링크드-리스트-circular-linked-list">3. 원형 링크드 리스트 (Circular Linked List)</h3>

<p>마지막 노드가 첫 노드를 가리킴</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     ┌─────────────────┐
     ↓                 │
Head → [10|●] → [20|●] → [30|●]
</code></pre></div></div>

<p><strong>장점:</strong></p>
<ul>
  <li>모든 노드 접근 가능 (시작점 무관)</li>
  <li>큐 구현에 유용</li>
</ul>

<p><strong>활용:</strong></p>
<ul>
  <li>라운드 로빈 스케줄링</li>
  <li>멀티플레이어 게임 (턴제)</li>
</ul>

<hr />

<h2 id="-배열-vs-링크드-리스트">📊 배열 vs 링크드 리스트</h2>

<h3 id="비교표">비교표</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>배열</th>
      <th>링크드 리스트</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>메모리</strong></td>
      <td>연속적</td>
      <td>비연속적</td>
    </tr>
    <tr>
      <td><strong>크기</strong></td>
      <td>고정</td>
      <td>동적</td>
    </tr>
    <tr>
      <td><strong>접근</strong></td>
      <td>O(1) ✅</td>
      <td>O(N) ❌</td>
    </tr>
    <tr>
      <td><strong>탐색</strong></td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td><strong>맨앞 삽입</strong></td>
      <td>O(N) ❌</td>
      <td>O(1) ✅</td>
    </tr>
    <tr>
      <td><strong>맨뒤 삽입</strong></td>
      <td>O(1) ✅</td>
      <td>O(N) ❌</td>
    </tr>
    <tr>
      <td><strong>중간 삽입</strong></td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td><strong>맨앞 삭제</strong></td>
      <td>O(N) ❌</td>
      <td>O(1) ✅</td>
    </tr>
    <tr>
      <td><strong>맨뒤 삭제</strong></td>
      <td>O(1) ✅</td>
      <td>O(N) ❌</td>
    </tr>
    <tr>
      <td><strong>중간 삭제</strong></td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td><strong>메모리 효율</strong></td>
      <td>높음 ✅</td>
      <td>낮음 (포인터) ❌</td>
    </tr>
    <tr>
      <td><strong>캐시 효율</strong></td>
      <td>높음 ✅</td>
      <td>낮음 ❌</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="상세-비교">상세 비교</h3>

<h4 id="1-접근-속도">1. 접근 속도</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열: O(1)</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>  <span class="c1">// 바로 접근</span>

<span class="c1">// 링크드 리스트: O(N)</span>
<span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// 100번 이동</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="2-메모리-사용">2. 메모리 사용</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>배열 (10개 int):
[10][20][30][40][50]...[100]
메모리: 4바이트 × 10 = 40바이트

링크드 리스트 (10개 int):
[10|●] → [20|●] → ... → [100|NULL]
메모리: (4바이트 + 8바이트) × 10 = 120바이트
(64비트 시스템에서 포인터 8바이트)

배열이 3배 효율적! ✅
</code></pre></div></div>

<h4 id="3-삽입삭제-비교">3. 삽입/삭제 비교</h4>

<p><strong>배열의 중간 삽입:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{10, 20, 30, 40, 50}에 25 삽입 (인덱스 2)

이동 필요: 30, 40, 50 → 3개
시간: O(N)
</code></pre></div></div>

<p><strong>링크드 리스트의 중간 삽입:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[10] → [20] → [30] → [40] → [50]에 25 삽입

찾기: 20까지 이동 → O(N)
삽입: 포인터 2개 변경 → O(1)
전체: O(N)
</code></pre></div></div>

<p><strong>결론: 삽입/삭제도 비슷하지만, 맨 앞 작업은 링크드 리스트가 유리</strong></p>

<h4 id="4-캐시-효율">4. 캐시 효율</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>배열:
[10][20][30][40][50]  ← 연속 메모리
캐시에 한 번에 로드 → 빠름 ✅

링크드 리스트:
[10] → [20] → [30] → [40] → [50]
각 노드가 다른 위치 → 캐시 미스 → 느림 ❌
</code></pre></div></div>

<hr />

<h2 id="-언제-무엇을-사용할까">🎯 언제 무엇을 사용할까?</h2>

<h3 id="배열을-사용해야-할-때-">배열을 사용해야 할 때 ✅</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 인덱스 접근이 빈번할 때
   예: arr[i], 랜덤 액세스

2. 크기가 고정되어 있을 때
   예: 학생 100명의 성적

3. 메모리가 제한적일 때
   예: 임베디드 시스템

4. 순차 접근이 많을 때
   예: for문으로 전체 순회
</code></pre></div></div>

<h3 id="링크드-리스트를-사용해야-할-때-">링크드 리스트를 사용해야 할 때 ✅</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 크기가 동적으로 변할 때
   예: 사용자 입력에 따라 크기 변화

2. 맨 앞 삽입/삭제가 빈번할 때
   예: 스택, 큐 구현

3. 중간 삽입/삭제가 빈번하고
   해당 위치를 이미 알고 있을 때
   예: 포인터로 위치를 저장해둔 경우

4. 메모리 단편화를 피하고 싶을 때
   예: 큰 연속 메모리 확보 어려움
</code></pre></div></div>

<hr />

<h1 id="실기-기출-유형">실기 기출 유형</h1>

<h2 id="-유형-1-코드-결과-예측">🎯 유형 1: 코드 결과 예측</h2>

<h3 id="배열-문제">배열 문제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>풀이:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: arr[] = {10, 20, 30, 40, 50}

반복문 실행:
i=0: arr[0] = 10 + 5 = 15
i=1: arr[1] = 20 + 5 = 25
i=2: arr[2] = 30 + 5 = 35
i=3: arr[3] = 40 + 5 = 45
i=4: arr[4] = 50 + 5 = 55

최종: arr[] = {15, 25, 35, 45, 55}

출력: arr[2]=35, arr[4]=55
답: 35 55
</code></pre></div></div>

<hr />

<h3 id="링크드-리스트-문제">링크드 리스트 문제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="c1">// 노드 생성 및 연결</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    
    <span class="n">head</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span>
    <span class="n">n1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n2</span><span class="p">;</span>
    <span class="n">n2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n3</span><span class="p">;</span>
    <span class="n">n3</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="c1">// 맨 앞에 5 삽입</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
    
    <span class="c1">// 출력</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>풀이:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 초기 리스트 생성:
Head → [10] → [20] → [30] → NULL

2. 맨 앞에 5 삽입:
newNode = [5]
newNode-&gt;next = head  → [5] → [10] → [20] → [30] → NULL
head = newNode

최종: Head → [5] → [10] → [20] → [30] → NULL

출력:
head-&gt;data = 5
head-&gt;next = [10]
head-&gt;next-&gt;next = [20]
head-&gt;next-&gt;next-&gt;data = 20

답: 5 20
</code></pre></div></div>

<hr />

<h2 id="-유형-2-빈칸-채우기">🎯 유형 2: 빈칸 채우기</h2>

<h3 id="배열-문제-1">배열 문제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열에서 최댓값 찾기</span>
<span class="kt">int</span> <span class="nf">findMax</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">______</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 빈칸 1</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">______</span><span class="p">;</span>          <span class="c1">// 빈칸 2</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>정답:</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>      <span class="c1">// 빈칸 1: &gt;</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>         <span class="c1">// 빈칸 2: arr[i]</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="링크드-리스트-문제-1">링크드 리스트 문제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 맨 뒤에 노드 삽입</span>
<span class="kt">void</span> <span class="nf">insertBack</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">______</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 빈칸 1</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">______</span><span class="p">;</span>             <span class="c1">// 빈칸 2</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>정답:</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 빈칸 1: next</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>          <span class="c1">// 빈칸 2: newNode</span>
</code></pre></div></div>

<hr />

<h2 id="-유형-3-알고리즘-작성">🎯 유형 3: 알고리즘 작성</h2>

<h3 id="배열-문제-배열-회전-왼쪽으로-1칸">배열 문제: 배열 회전 (왼쪽으로 1칸)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열을 왼쪽으로 1칸 회전</span>
<span class="c1">// {10, 20, 30, 40} → {20, 30, 40, 10}</span>

<span class="kt">void</span> <span class="nf">rotateLeft</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// 첫 원소 저장</span>
    
    <span class="c1">// 왼쪽으로 이동</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="n">arr</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>  <span class="c1">// 마지막에 저장</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>동작 과정:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: {10, 20, 30, 40}

temp = 10

이동:
arr[0] = arr[1] → {20, 20, 30, 40}
arr[1] = arr[2] → {20, 30, 30, 40}
arr[2] = arr[3] → {20, 30, 40, 40}

마지막에 temp 배치:
arr[3] = temp → {20, 30, 40, 10}
</code></pre></div></div>

<hr />

<h3 id="배열-문제-두-배열-합치기">배열 문제: 두 배열 합치기</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// arr1과 arr2를 result에 합치기</span>
<span class="kt">void</span> <span class="nf">mergeArrays</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr1</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size1</span><span class="p">,</span> 
                 <span class="kt">int</span> <span class="n">arr2</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size2</span><span class="p">,</span> 
                 <span class="kt">int</span> <span class="n">result</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    
    <span class="c1">// arr1 복사</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="c1">// arr2 복사</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N + M)</span>
</code></pre></div></div>

<p><strong>예시:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arr1[] = {10, 20, 30}  (size1 = 3)
arr2[] = {40, 50}      (size2 = 2)

결과: result[] = {10, 20, 30, 40, 50}
</code></pre></div></div>

<hr />

<h3 id="링크드-리스트-문제-리스트-역순">링크드 리스트 문제: 리스트 역순</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 링크드 리스트를 역순으로 변경</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">// 다음 노드 저장</span>
        <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>     <span class="c1">// 방향 전환</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>           <span class="c1">// prev 이동</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>           <span class="c1">// current 이동</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">prev</span><span class="p">;</span>  <span class="c1">// 새로운 head</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>동작 과정:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: [10] → [20] → [30] → NULL

1단계: current = [10]
next = [20]
[10] → NULL (방향 전환)
prev = [10], current = [20]

2단계: current = [20]
next = [30]
[20] → [10] → NULL
prev = [20], current = [30]

3단계: current = [30]
next = NULL
[30] → [20] → [10] → NULL
prev = [30], current = NULL

최종: [30] → [20] → [10] → NULL
</code></pre></div></div>

<hr />

<h3 id="링크드-리스트-문제-중간-노드-찾기">링크드 리스트 문제: 중간 노드 찾기</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 리스트의 중간 노드 찾기 (Fast &amp; Slow Pointer)</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">findMiddle</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="n">Node</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    
    <span class="c1">// fast는 2칸, slow는 1칸씩 이동</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>  <span class="c1">// slow가 중간 지점</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>동작 과정:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>리스트: [10] → [20] → [30] → [40] → [50] → NULL

초기:
slow = [10], fast = [10]

1단계:
slow = [20], fast = [30]

2단계:
slow = [30], fast = [50]

3단계:
fast-&gt;next = NULL → 종료
slow = [30] ✅ (중간 노드)
</code></pre></div></div>

<hr />

<h3 id="링크드-리스트-문제-순환-감지">링크드 리스트 문제: 순환 감지</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 리스트에 순환(Cycle)이 있는지 확인</span>
<span class="n">bool</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="n">Node</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
        <span class="c1">// 만나면 순환 있음</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 순환 없음</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>동작 원리:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>순환이 있는 경우:
[10] → [20] → [30] → [40]
              ↑       ↓
              └───────┘

slow와 fast가 언젠가 만남 ✅

순환이 없는 경우:
[10] → [20] → [30] → [40] → NULL

fast가 NULL에 도달 → 순환 없음 ✅
</code></pre></div></div>

<hr />

<h2 id="-유형-4-개념-서술">🎯 유형 4: 개념 서술</h2>

<h3 id="q1-배열과-링크드-리스트의-차이점을-3가지-서술하시오">Q1: 배열과 링크드 리스트의 차이점을 3가지 서술하시오.</h3>

<p><strong>답:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 메모리 구조:
   - 배열: 연속된 메모리 공간에 저장
   - 링크드 리스트: 비연속적 메모리, 포인터로 연결

2. 접근 속도:
   - 배열: 인덱스로 직접 접근 O(1)
   - 링크드 리스트: 순차 접근 O(N)

3. 크기 변경:
   - 배열: 고정 크기, 변경 불가
   - 링크드 리스트: 동적 크기, 자유롭게 변경 가능
</code></pre></div></div>

<hr />

<h3 id="q2-배열에서-중간-삽입의-시간복잡도가-on인-이유를-설명하시오">Q2: 배열에서 중간 삽입의 시간복잡도가 O(N)인 이유를 설명하시오.</h3>

<p><strong>답:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>중간에 데이터를 삽입하려면 해당 위치 이후의
모든 원소를 한 칸씩 뒤로 이동해야 합니다.

예: {10, 20, 30, 40, 50}의 인덱스 2에 25 삽입

1. 50을 인덱스 5로 이동
2. 40을 인덱스 4로 이동
3. 30을 인덱스 3으로 이동
4. 인덱스 2에 25 삽입

이동 횟수는 (배열 크기 - 삽입 위치)이므로
최악의 경우(맨 앞 삽입) N번 이동 → O(N)
</code></pre></div></div>

<hr />

<h3 id="q3-링크드-리스트에서-맨-뒤-삽입이-on인데-이를-o1로-개선하는-방법은">Q3: 링크드 리스트에서 맨 뒤 삽입이 O(N)인데, 이를 O(1)로 개선하는 방법은?</h3>

<p><strong>답:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tail 포인터를 추가로 유지합니다.

구조:
typedef struct List {
    Node* head;
    Node* tail;  // 마지막 노드를 가리킴
} List;

삽입 시:
1. newNode 생성
2. tail-&gt;next = newNode
3. tail = newNode

Tail 포인터로 마지막 노드를 바로 접근하므로
순회 없이 O(1)에 삽입 가능합니다.
</code></pre></div></div>

<hr />

<h3 id="q4-이중-링크드-리스트의-장점과-단점을-설명하시오">Q4: 이중 링크드 리스트의 장점과 단점을 설명하시오.</h3>

<p><strong>답:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>장점:
1. 양방향 탐색 가능 (prev 포인터)
2. 특정 노드 삭제 시 이전 노드 찾기 쉬움
3. 역순 순회 가능

단점:
1. 메모리 사용량 증가 (포인터 2개)
2. 삽입/삭제 시 포인터 관리 복잡 (prev, next 모두 처리)
3. 구현 난이도 증가

활용:
- 브라우저의 앞/뒤 이동
- 텍스트 에디터의 Undo/Redo
- LRU 캐시 구현
</code></pre></div></div>

<hr />

<h2 id="-실전-응용-문제">💡 실전 응용 문제</h2>

<h3 id="문제-1-배열에서-두-수의-합">문제 1: 배열에서 두 수의 합</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열에서 합이 target인 두 수의 인덱스 찾기</span>
<span class="c1">// arr[] = {2, 7, 11, 15}, target = 9</span>
<span class="c1">// 답: [0, 1] (2 + 7 = 9)</span>

<span class="kt">void</span> <span class="nf">twoSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"[%d, %d]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N²)</span>
</code></pre></div></div>

<hr />

<h3 id="문제-2-배열-회전-오른쪽으로-k칸">문제 2: 배열 회전 (오른쪽으로 k칸)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 배열을 오른쪽으로 k칸 회전</span>
<span class="c1">// arr[] = {1, 2, 3, 4, 5}, k = 2</span>
<span class="c1">// 결과: {4, 5, 1, 2, 3}</span>

<span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="n">start</span><span class="o">++</span><span class="p">;</span>
        <span class="n">end</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rotateRight</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>  <span class="c1">// k가 size보다 클 경우 대비</span>
    
    <span class="c1">// 1. 전체 역순</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="c1">// 2. 앞 k개 역순</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="c1">// 3. 나머지 역순</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>동작 과정:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>초기: {1, 2, 3, 4, 5}, k = 2

1. 전체 역순:
{5, 4, 3, 2, 1}

2. 앞 2개 역순:
{4, 5, 3, 2, 1}

3. 나머지 역순:
{4, 5, 1, 2, 3} ✅
</code></pre></div></div>

<hr />

<h3 id="문제-3-링크드-리스트-병합-정렬된-두-리스트">문제 3: 링크드 리스트 병합 (정렬된 두 리스트)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정렬된 두 리스트를 병합하여 정렬된 하나의 리스트로</span>
<span class="c1">// list1: [1] → [3] → [5]</span>
<span class="c1">// list2: [2] → [4] → [6]</span>
<span class="c1">// 결과: [1] → [2] → [3] → [4] → [5] → [6]</span>

<span class="n">Node</span><span class="o">*</span> <span class="nf">mergeSortedLists</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 더미 노드 생성</span>
    <span class="n">Node</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
    <span class="n">dummy</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span><span class="p">;</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span><span class="p">;</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 남은 노드 연결</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N + M)</span>
</code></pre></div></div>

<hr />

<h3 id="문제-4-링크드-리스트에서-n번째-뒤-노드-삭제">문제 4: 링크드 리스트에서 N번째 뒤 노드 삭제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 뒤에서 N번째 노드 삭제</span>
<span class="c1">// 리스트: [1] → [2] → [3] → [4] → [5], N = 2</span>
<span class="c1">// 결과: [1] → [2] → [3] → [5] (4 삭제)</span>

<span class="n">Node</span><span class="o">*</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">dummy</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    
    <span class="n">Node</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">second</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
    
    <span class="c1">// first를 n+1칸 앞서게 이동</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 둘 다 이동 (간격 유지)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 삭제</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 시간복잡도: O(N)</span>
</code></pre></div></div>

<p><strong>동작 과정:</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>리스트: [1] → [2] → [3] → [4] → [5], N = 2

1. first를 n+1=3칸 이동:
first → [4], second → [dummy]

2. 둘 다 끝까지 이동 (간격 유지):
first → NULL, second → [3]

3. second-&gt;next (4) 삭제:
[1] → [2] → [3] → [5]
</code></pre></div></div>

<hr />

<h2 id="-핵심-암기-사항">📝 핵심 암기 사항</h2>

<h3 id="배열-array">배열 (Array)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 연속된 메모리
✅ 고정 크기
✅ 인덱스 접근: O(1)
✅ 탐색: O(N)
✅ 맨뒤 삽입/삭제: O(1)
✅ 중간 삽입/삭제: O(N)
✅ 메모리 효율적
✅ 캐시 친화적

주소 계산: 시작주소 + (인덱스 × 데이터크기)
</code></pre></div></div>

<h3 id="링크드-리스트-linked-list">링크드 리스트 (Linked List)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 비연속적 메모리
✅ 동적 크기
✅ 인덱스 접근: O(N)
✅ 탐색: O(N)
✅ 맨앞 삽입/삭제: O(1)
✅ 맨뒤 삽입/삭제: O(N) (Tail 없을 때)
✅ 중간 삽입/삭제: O(N)
✅ 포인터 메모리 오버헤드

노드 구조: data + next 포인터
</code></pre></div></div>

<h3 id="시간복잡도-비교">시간복잡도 비교</h3>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>배열</th>
      <th>링크드 리스트</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>접근</td>
      <td><strong>O(1)</strong></td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td>탐색</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td>맨앞 삽입</td>
      <td>O(N)</td>
      <td><strong>O(1)</strong></td>
    </tr>
    <tr>
      <td>맨뒤 삽입</td>
      <td><strong>O(1)</strong></td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td>중간 삽입</td>
      <td>O(N)</td>
      <td>O(N)</td>
    </tr>
    <tr>
      <td>맨앞 삭제</td>
      <td>O(N)</td>
      <td><strong>O(1)</strong></td>
    </tr>
    <tr>
      <td>맨뒤 삭제</td>
      <td><strong>O(1)</strong></td>
      <td>O(N)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="-실기-시험-팁">🎓 실기 시험 팁</h2>

<h3 id="1-배열-인덱스-주의">1. 배열 인덱스 주의</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>  <span class="c1">// 인덱스: 0, 1, 2, 3, 4</span>

<span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// ❌ 범위 초과 (Undefined Behavior)</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// ✅ 올바름</span>
</code></pre></div></div>

<h3 id="2-포인터-초기화">2. 포인터 초기화</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// ✅ 반드시 초기화</span>

<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// NULL 체크 습관화</span>
    <span class="c1">// 처리</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-메모리-해제">3. 메모리 해제</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>  <span class="c1">// ✅ 반드시 해제</span>
</code></pre></div></div>

<h3 id="4-이중-포인터-이해">4. 이중 포인터 이해</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertFront</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// *head를 수정하려면 **head 필요</span>
    <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="5-경계-조건-체크">5. 경계 조건 체크</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 빈 리스트</span>
<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// 노드 1개</span>
<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// 배열 범위</span>
<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<hr />

<p><strong>check list:</strong></p>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />배열과 링크드 리스트를 직접 그려가며 이해하기</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />포인터 동작을 단계별로 추적하기</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />시간복잡도를 항상 함께 생각하기</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />기출문제를 반복해서 풀어보기</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />코드를 손으로 직접 작성해보기</li>
</ul>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 yunYoung e. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
